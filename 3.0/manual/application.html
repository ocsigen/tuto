<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Writing a client/server Eliom application</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js"></script><script src="/js/client.js"></script></head><body class="tuto 3.0"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href="/" class="ocsimore_phrasing_link"><img src="/img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Doc
</p><ul class="mainmenu"><li class="mainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="mainmenu-doc mainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li></ul><div class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc drawermainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li><a href="/ocsigenserver/2.9/manual/quickstart" class="ocsimore_phrasing_link">Server</a>
</li><li><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li><a href="/ocsigen-toolkit/1.1.0/manual/intro" class="ocsimore_phrasing_link">Toolkit</a>
</li><li><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-page"><a href="/projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href="/papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href="/credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li></ul><div class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/3.0/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/3.0/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/3.0/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/3.0/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/3.0/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h1> Mini-tutorials: Some little examples</h1><h2><a href="/tuto/3.0/manual/tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client server widgets</a></h2><h2><a href="/tuto/3.0/manual/macaque" class="ocsimore_phrasing_link">MaCaQue: SQL queries</a></h2><h2><a href="/tuto/3.0/manual/custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="/tuto/3.0/manual/ocsipersist" class="ocsimore_phrasing_link">Light database</a></h2><h2><a href="/tuto/3.0/manual/pictures" class="ocsimore_phrasing_link">Upload pictures</a></h2><h2><a href="/tuto/3.0/manual/music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="/tuto/3.0/manual/hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h2></div></nav></div></div><button id="reason">Switch to </button><div class="twocols"><div class="leftcol"><div class="how-versions"><input id="how-versions-toggle" type="checkbox"/><label for="how-versions-toggle" class="how-versions-current">Version 3.0</label><div class="how-versions-all"><a href="/tuto/dev/manual/application">dev</a><a href="/tuto/6.2/manual/application">6.2</a><a href="/tuto/6.1/manual/application">6.1</a><a href="/tuto/6.0/manual/application">6.0</a><a href="/tuto/5.0/manual/application">5.0</a><a href="/tuto/4.2/manual/application">4.2</a><a href="/tuto/4.1/manual/application">4.1</a><a href="/tuto/4.0/manual/application">4.0</a><span class="how-versions-all-current">3.0</span><a href="/tuto/2.2/manual/application">2.2</a><a href="/tuto/2.0/manual/application">2.0</a></div></div><form id="search"><input name="q" id="q" placeholder="search ..."/><button>Search</button></form><div class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/3.0/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/3.0/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/3.0/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/3.0/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/3.0/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h1> Mini-tutorials: Some little examples</h1><h2><a href="/tuto/3.0/manual/tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client server widgets</a></h2><h2><a href="/tuto/3.0/manual/macaque" class="ocsimore_phrasing_link">MaCaQue: SQL queries</a></h2><h2><a href="/tuto/3.0/manual/custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="/tuto/3.0/manual/ocsipersist" class="ocsimore_phrasing_link">Light database</a></h2><h2><a href="/tuto/3.0/manual/pictures" class="ocsimore_phrasing_link">Upload pictures</a></h2><h2><a href="/tuto/3.0/manual/music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="/tuto/3.0/manual/hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h2></div></div><div class="rightcol"><header><h1>Writing a client/server Eliom application</h1></header><p><em>The code of this tutorial has been tested with Eliom3.</em> <br/>
</p><p>In this chapter, we will write a <a href="/graffiti/" class="ocsimore_phrasing_link">collaborative
drawing application</a>.  It is a client/server web application
displaying an area where users can draw using the mouse, and see what
other users are drawing at the same time and in real-time.
</p>The final eliom code is available
<a href="/darcs/tutorial/files/tutorial/chapter1/distillery-oclosure/" class="ocsimore_phrasing_link">for download</a>.<h2 id="basics"> Basics <a class="backref" href="#basics">&#182;</a></h2><p>To get started, we recommend to use <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/workflow-distillery">Eliom's distillery</a></span>, a program which
creates scaffolds for Eliom projects. The following command creates a
very simplicistic project called &quot;graffiti&quot; in the directory
&quot;graffiti&quot; (adapt it to your needs!):
</p><pre class="manually-translated"><code class="language-shell">$ eliom-destillery -name graffiti -template basic -destination graffiti</code></pre><h3>My first page</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services<br/>Configuration file<br/>Static validation of HTML</p></aside><p>Our web application consists of a single page for now. Let's start by
creating a very basic page.  We define the service that will implement
this page by the following declaration:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content.Html5.D (* provides functions to create HTML nodes *)

let main_service =
  Eliom_registration.Html5.register_service
    ~path:[&quot;graff&quot;]
    ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (pcdata &quot;Page title&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]])))</code></pre><p>If you're using <span class="teletype">eliom-destillery</span> just replace the content of the
eliom-file by the above lines and run
</p><pre class="manually-translated"><code class="language-shell">$ make test.byte</code></pre><p>This will compile your application and run <span class="teletype">ocsigenserver</span> on it.
(Refer to the <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/workflow-compilation">manual</a></span> on how to compile your project
&quot;by hand&quot;.)
</p><p>Your page is now available at URL <a href="http://localhost:8080/graff" class="ocsimore_phrasing_link"><span class="teletype">http://localhost:8080/graff</span></a>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Services</h5></header><p>Unlike typical web programming techniques (CGI, PHP, ...), with
Eliom, you don't write one file for each URL, but a single OCaml module
(*.cmo or *.cma) for the whole web site.
</p><p>The <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_service">Eliom_service</a></span> module allows
to create new entry points to your web site, called <em>services</em>. In
general, services are attached to a URL and generate a web page.
Services are represented by OCaml values, through which you must
register a function that will generate a page.
</p><p>The <span class="teletype">~path</span> parameter corresponds to the URL where you want to
attach your service. It is a list of strings.  The value
<code>[&quot;foo&quot;; &quot;bar&quot;]</code> corresponds to the URL
<code>foo/bar</code>.  <code>[&quot;dir&quot;; &quot;&quot;]</code> corresponds to
the URL <code>dir/</code> (that is: the default page of the
directory <code>dir</code>).</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Configuration file</h5></header><p>In the directory of the project created by the Eliom-destillery, you
can find the file <span class="teletype">graffiti.conf.in</span>. From this file and the
variables in <span class="teletype">Makefile.options</span>, the configuration file for
<span class="teletype">ocsigenserver</span> are generated. After testing your application, it
is available as <span class="teletype">local/etc/graffiti/graffiti-test.conf</span>
</p><p>It contains various directives for Ocsigen server (port, log files,
extensions to be loaded, etc.), taken from <span class="teletype">Makefile.options</span> and
something like:
</p><pre>&lt;host&gt;
    &lt;static dir=&quot;static&quot; /&gt;
    &lt;eliommodule module=&quot;/path_to/graffiti.cma&quot; /&gt;
    &lt;eliom /&gt;
&lt;/host&gt;
</pre><p>These instructions tell the server to:
</p><ul><li> serve files from the directory <code>/path_to/graffiti/static</code> if they exist,
</li><li> generate pages from services in the Eliom application
<span class="teletype">graffiti.cma</span> otherwise.
</li><li> and finally, <em>run</em> Eliom (<span class="teletype">&lt;eliom /&gt;</span>).</li></ul></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Static validation of HTML</h5></header><p>There are several ways to create pages for Eliom.  You can generate
pages as strings (as in other web frameworks).  But we prefer checking
at compile time that the HTML will be correct.  Eliom provides several
modules to do that, either using OcamlDuce (if you have it installed)
or using OCaml's polymorphic variants.  This tutorial is using the
second solution, using the module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D">Eliom_content.​Html5.​D</a></span>. This module defines a
construction function for each HTML5 tag.
</p><p><em>Note that it is also possible to use the usual HTML syntax directly
in OCaml, cf.  <span><a class="ocsforge_doclink_tyxml" href="/tyxml/4.1.0/api/Pa_tyxml">Pa_tyxml</a></span>.</em>
</p><p>Ocsigen uses the <span><a class="ocsforge_doclink_tyxml" href="/tyxml/dev/manual/intro">TyXML</a></span>
library to build HTML tree.  The TyXML library is very strict and
compels you to respect HTML5 standard (with some limitations). For
example if you write:
</p><pre class=""><code class="language-ocaml translatable">(html
   (head (title (pcdata &quot;&quot;)) [pcdata &quot;&quot;])
   (body [pcdata &quot;Hallo&quot;]))</code></pre><p>You will get the following error message, referring at the end of line 2:
</p><pre>Error: This expression has type ([&gt; `PCDATA ] as 'a) Html5.elt
       but an expression was expected of type Html5_types.head_content_fun Html5.elt
       Type 'a is not compatible with type Html5_types.head_content_fun =
           [ `Base
           | `Command
           | `Link
           | `Meta
           | `Noscript of [ `Link | `Meta | `Style ]
           | `Script
           | `Style ]
       The second variant type does not allow tag(s) `PCDATA
</pre><p>where <span><a class="ocsforge_doclink_tyxml" href="/tyxml/4.1.0/api/Html5_types#TYPEhead_content_fun">Html5_types.​head_content_fun</a></span>
is the type of content allowed inside <span class="teletype">&lt;head&gt;</span> (<span class="teletype">&lt;base&gt;</span>,
<span class="teletype">&lt;command&gt;</span>, <span class="teletype">&lt;link&gt;</span>, <span class="teletype">&lt;meta&gt;</span>, etc.). You see that
<span class="teletype">`PCDATA</span> (i.e. raw text) is not included in this polymorphic
variant type.
</p><p><strong>Another example:</strong> In HTML5, some tags cannot be empty. For example
<span class="teletype">&lt;table&gt;</span>must contain at least one row.  To enforce this, the
<span><a class="ocsforge_doclink_tyxml" href="/tyxml/dev/api/Html5.F#VALtable">Html5.table</a></span> function takes two parameters: the first one is the
first row, the second one is a list containing all the other rows
(same thing for <span class="teletype">&lt;tr&gt;</span>, <span class="teletype">&lt;form&gt;</span>, <span class="teletype">&lt;select&gt;</span>, ...).  This
forces the user to handle the empty list case specially and thus make
the output conform to the recommendation from the W3C.
</p><p><em>Strict typing of HTML may seem arduous initially, but in fact it is
very easy to get used to.  It actually saves a huge amount of
debugging time as you will never have to bother about the validity of
pages afterwards.</em>
</p><p>A more detailed introduction to the construction of HTML5 tree is
available in the <span><a class="ocsforge_doclink_tyxml" href="/tyxml/4.1.0/api/Html5.F">TyXML reference API</a></span>.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Lwt</h5></header><p><strong>Important warning:</strong> All the functions you write must be written in
cooperative manner using Lwt. Lwt is a convenient way to
implement concurrent programs in OCaml, and is now also widely used
for applications not related to Ocsigen.
</p><p>For now we will just use the <span class="teletype">Lwt.return</span> function as above.  We
will come back later on Lwt programming.  You can also have a look at
the <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/manual/manual">Lwt programming guide</a></span>.</p></aside><h3>Execute parts of the program on the client</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Service sending an application<br/>
Client and server code<br/>
Compiling a web application with server and client parts<br/>
Calling JavaScript methods with Js_of_ocaml<br/></p></aside><p>To create our first service, we used the function <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_registration.Html5#VALregister_service">Eliom_registration.​Html5.​register_service</a></span>, as we
wanted to return HTML5. But actually we want our service to send an
Eliom application.  To do so, we will create our own registration
module by using the functor <span class="teletype">Eliom_registration.App</span>:
</p><pre class=""><code class="language-ocaml translatable">module My_app =
  Eliom_registration.App (struct
      let application_name = &quot;graffiti&quot;
    end)</code></pre><p>It is now possible to use <span class="teletype">My_app</span> for registering our main
service (now at URL <span class="teletype">/</span>):
</p><pre class=""><code class="language-ocaml translatable">let main_service =
  My_app.register_service
    ~path:[&quot;graff&quot;]
    ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (pcdata &quot;Graffiti&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]]) ) )</code></pre><p>We now want to add some OCaml code to be executed by the browser. For
that purpose, Eliom provides a syntax extension to distinguish between
server and client code in the same file. We start by a very basic
program, that will display a message to the user by calling the
JavaScript function <span class="teletype">alert</span>. Add the following lines to the
program,
</p><pre class=""><code class="language-ocaml translatable">{client{
  let _ = Eliom_lib.alert &quot;Hello!&quot;
}}</code></pre><p>After running again <span class="teletype">make test.byte</span>, and visiting
<a href="http://localhost:8080/graff" class="ocsimore_phrasing_link">http://localhost:8080/graff</a>, the browser will now load the file
<span class="teletype">graffiti.js</span>, and open an alert-box accordingly.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Splitting the code into server and client parts</h5></header><p>Eliom's syntax extension implements four kinds of quotations. Three of
them are available at source file toplevel:
</p><p>At the very toplevel of your source file (i.e. <em>not</em> inside modules
or other server- /client-parts), you can use the following quotations
to specify for which side the code should run.
</p><ul><li> <span class="teletype"> {client{ ... }} </span> for client side specific code.
</li><li> <span class="teletype"> {server{ ... }} </span> (optional) for server side specific code.
</li><li> <span class="teletype"> {shared{ ... }} </span> for code that will be used both for the server and the client.
</li><li> Code outside of those quotations is assument to be only for server side.
</li></ul><p>In the Makefile created by the distillery we automatically split the
code by a syntax extension, compile the server part as usual, and
compile the client part using <span class="teletype">js_of_ocaml</span> to create a JavaScript
file.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client values on the server</h5></header><p>Additionally, it is possible to create client values within the server
code by the following quotation:
</p><pre class=""><code class="language-ocaml translatable">{typ{ expr }}</code></pre><p>where <span class="teletype">typ</span> is the type of an expression <span class="teletype">expr</span> on the client.
Note, that such a client values is abstract on the server, but becomes
concrete, once it is sent to the client with the next request.
</p><p>(The <span class="teletype">typ</span> can be ommitted, when it can be inferred from the usage of the client value in the server code.)</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Js_of_ocaml</h5></header><p>The client-side parts of the program are compiled to JavaScript by
<span class="teletype">js_of_ocaml</span>, which recompiles OCaml bytecode, to JavaScript.
It is <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/manual/bindings">easy</a></span>
to bind JavaScript libraries to call JavaScript functions
from OCaml programs. In the example, we are using the <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Dom_html">Dom_html</a></span> module, which is a binding
to allow the manipulation of an HTML page.
</p><p>Js_of_ocaml is using a syntax extension to call JavaScript methods:
</p><ul><li> <span class="teletype">obj##m(a, b, c)</span> to call the method <span class="teletype">m</span> of object <span class="teletype">obj</span>
with parameters <span class="teletype">(a, b, c)</span>
</li><li> <span class="teletype">obj##m</span> to get a property
</li><li> <span class="teletype">obj##m &lt;- e</span> to set a property
</li><li> <span class="teletype">jsnew constr (e1, ..., en)</span> to call a JavaScript constructor
</li></ul><p>Find more information in <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/manual/overview">Js_of_ocaml's manual </a></span>.</p></aside><h3>Accessing server side variables on client side code</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Executing client side code after loading a page<br/>
Sharing server side values<br/>
Converting an HTML value to a portion of page (a.k.a. Dom node)<br/>
Manipulating HTML node 'by reference'</p></aside><p>The client side process is not really separated from the server side,
we can access some server variables from client code. For instance:
</p><pre class=""><code class="language-ocaml translatable">let count = ref 0

let main_service =
  My_app.register_service
     ~path:[&quot;&quot;]
     ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      let count = incr count; !count in
      ignore {unit{
        Dom_html.window##alert(Js.string
	  (Printf.sprintf &quot;You came %i times to this page&quot; %count))
      }};
      Lwt.return
        (html
           (head (title (pcdata &quot;Graffiti&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]]) ) )</code></pre><p>Here, we are increasing the reference <span class="teletype">count</span> each time the page
is accessed. When the page is loaded and the document is in-place,
the client program initialize
the value inside <span class="teletype"> {unit{ ... }} </span> and thus triggers an alert
window. More specifically, the variable <span class="teletype"> count </span>, in the scope of
the client value on the server is made available in the client value
using the syntax extension <span class="teletype">%count</span>. In doing so, the server side
value <span class="teletype"> count </span> is displayed in a message box on the client.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Injections: Using server side values in client code</h5></header><p>Client side code can reference copies of server side values using
the <span class="teletype">%variable</span> syntax.  Values sent that way are
weakly type checked: the name of the client side type must match the
server side one.  If you define a type and want it to be available
on both sides, declare it in the section <span class="teletype"> {shared{ ... }} </span>. See the Eliom
manual, for more information anout the <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/clientserver-language">Eliom's syntax extension </a></span>
and its <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/workflow-compilation#compilation">compilation process</a></span>.
</p><p>Note well, that the value of an injection into a section <span class="teletype"> {client{ ... }} </span>
is sent only once when starting the application
in the browser, and <em>not</em> synced automatically later (you may want
to use <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_react">Eliom_react</a></span>, however).
</p><p>In contrast, the values of injections into client values which are
created during a request are sent alongside the next response.</p></aside><h2 id="graffiti"> Collaborative drawing application <a class="backref" href="#graffiti">&#182;</a></h2><h3>Drawing on a canvas</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Canvas</p></aside><p>We now want to draw something on the page using an HTML5 canvas. The
drawing primitive is defined in the client-side function called
<span class="teletype">draw</span> that just draws a line between two given points in a canvas.
</p><p>To start our collaborative drawing application, we define another
client-side function <span class="teletype"> init_client </span>, which just draws a single,
<span style="color:#ffaa33;">orange</span> line for now.
</p><p>Here is the (full) new version of the program:
</p><pre class=""><code class="language-ocaml translatable">{shared{
  (* Modules open in the shared-section are available in client-
      and server-code! *)
  open Eliom_content.Html5.D
  open Lwt
}}

module My_app =
  Eliom_registration.App (
    struct
      let application_name = &quot;graffiti&quot;
    end)

{shared{
  open Eliom_content.Html5.D
  let width = 700
  let height = 400
}}

{client{
  let draw ctx (color, size, (x1, y1), (x2, y2)) =
    ctx##strokeStyle &lt;- (Js.string color);
    ctx##lineWidth &lt;- float size;
    ctx##beginPath();
    ctx##moveTo(float x1, float y1);
    ctx##lineTo(float x2, float y2);
    ctx##stroke()
}}

let canvas_elt =
  canvas ~a:[a_width width; a_height height]
    [pcdata &quot;your browser doesn't support canvas&quot;]

let page =
  (html
    (head (title (pcdata &quot;Graffiti&quot;)) [])
    (body [h1 [pcdata &quot;Graffiti&quot;];
           canvas_elt] ) )
{client{
  let init_client () =
    let canvas = Eliom_content.Html5.To_dom.of_canvas %canvas_elt in
    let ctx = canvas##getContext (Dom_html._2d_) in
    ctx##lineCap &lt;- Js.string &quot;round&quot;;
    draw ctx (&quot;#ffaa33&quot;, 12, (10, 10), (200, 100))
}}

let main_service =
  My_app.register_service ~path:[&quot;&quot;] ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      (* Cf. the box &quot;Client side side-effects on the server&quot; *)
      ignore {unit{ init_client () }};
      Lwt.return page)</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>JavaScript datatypes in OCaml</h5></header><p>Note that we use the function <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Js#VALstring">Js.​string</a></span> from the Js_of_ocaml's library to convert an OCaml
string into a JS string.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client side side-effect on the server</h5></header><p>What sounds a bit weird at first, is a very convenient practice for
processing request in a client-server application: If a client value
is created while processing a request, it will be evaluated on the
client once he receives the response and the document is put in place;
with this, the corresponding side effects are executed, of course.
</p><p>In the example above the line
</p><pre class=""><code class="language-ocaml translatable">ignore {unit{ init_client () }};</code></pre><p>creates such a client value which consists only of side effects, so
the value can be <span class="teletype">ignore</span>d, but Eliom will evaluate the value
anyway, justs because it has been created!</p></aside><h3>Single user drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Lwt<br/>
Mouse events with Lwt</p></aside><p>We now want to catch mouse events to draw lines with the mouse like
with the <em>brush</em> tools of any classical drawing application. One
solution would be to mimic classical JavaScript code in OCaml ; for
example by using the function <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Dom_events#VALlisten">Dom_events.​listen</a></span> that is the Js_of_ocaml's equivalent of
<span class="teletype">addEventListener</span>. However, this solution is at least as much
verbose than the JavaScript equivalent, hence not
satisfactory. Js_of_ocaml's library provides a much easier way to do that,
together with Lwt.
</p><p>Replace the <span class="teletype">init_client</span> of the previous example by the
following piece of code, then compile and draw!
</p><pre class=""><code class="language-ocaml translatable">{client{
let init_client () =

  let canvas = Eliom_content.Html5.To_dom.of_canvas %canvas_elt in
  let ctx = canvas##getContext (Dom_html._2d_) in
  ctx##lineCap &lt;- Js.string &quot;round&quot;;

  let x = ref 0 and y = ref 0 in

  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##clientX - x0; y := ev##clientY - y0
  in

  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    (&quot;#ff9933&quot;, 5, (oldx, oldy), (!x, !y))
  in

  let line ev = draw ctx (compute_line ev); Lwt.return () in

  Lwt.async
    (fun () -&gt;
      let open Lwt_js_events in
      mousedowns canvas
        (fun ev _ -&gt;
          set_coord ev; line ev ~&gt;&gt;= fun () -&gt;
          Lwt.pick [mousemoves Dom_html.document (fun x _ -&gt; line x);
		    mouseup Dom_html.document ~&gt;&gt;= line]))
}}</code></pre><p>We use two references <span class="teletype">x</span> and <span class="teletype">y</span> to record the last mouse
position.  The function <span class="teletype">set_coord</span> updates those references from
mouse event data.  The function <span class="teletype">compute_line</span> computes the
coordinates of a line from the initial (old) coordinates to the new
coordinates–the event data sent as a parameter.
</p><p>The last four lines of code, that implement the event handling loop, could be
read as: for each <span class="teletype">mousedown</span> event on the canvas, do
<span class="teletype">set_coord</span> then <span class="teletype">line</span> (this will draw a dot), then
behave as the <span class="teletype">first</span> of the two following lines to
terminate:
</p><ul><li> For each mousemove event on the document, call <span class="teletype">line</span> (never terminates)
</li><li> If there is a mouseup event on the document, call <span class="teletype">line</span>.
</li></ul><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>More on Lwt</h5></header><p>Functions in Eliom and Js_of_ocaml which do not implement just a
computation or direct side effect but are waiting for user activity,
file system access or need a unforseeable amount of time to return are
defined <em>in Lwt</em>; instead of returning a value of type <span class="teletype">a</span> they
return an Lwt-thread of type <span class="teletype">a Lwt.t</span>.
</p><p>The only way to use the result of such functions (ones that return
values in the <em>Lwt monad</em>), is to use <span class="teletype">Lwt.bind</span>.
</p><pre class=""><code class="language-ocaml translatable">Lwt.bind : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b
Lwt.t</code></pre><p>It is convenient to define an infix operator like this: </p><pre class=""><code class="language-ocaml translatable">let (~&gt;&gt;=) = Lwt.bind</code></pre><p>Then the code </p><pre class=""><code class="language-ocaml translatable">f () ~&gt;&gt;= fun x -&gt;</code></pre><p>has to be read as </p><pre class=""><code class="language-ocaml translatable">let x = f () in</code></pre><p>but only for functions returning a
value in the Lwt monad.<br/>
</p><p>For more clarity, there is a syntax extension for Lwt, defining a
new keyword <span class="teletype">lwt</span> to be used instead of <span class="teletype">let</span> for Lwt
functions: </p><pre class=""><code class="language-ocaml translatable">lwt x = f () in</code></pre><p><span class="teletype">Lwt.return</span> creates a terminated thread from a value (without
inserting a cooperation point):
</p><pre class=""><code class="language-ocaml translatable">Lwt.return : 'a -&gt; 'a Lwt.t</code></pre><p>Use it when you must return something in the Lwt
monad (for example in a service handler, or often after a
<span class="teletype">Lwt.bind</span>).
</p><h5>Why Lwt?</h5><p>An Eliom application is a cooperative program, as the server must be
able to handle several requests at the same time.  Ocsigen is using
cooperative threading instead of the more widely used preemptive
threading paradigm. It means that no scheduler will interrupt your
functions whenever it wants. Switching from one thread to another is
done only when there is a <em>cooperation point</em>.
</p><p>We will use the term <em>cooperative functions</em> to identify functions
implemented in cooperative way, that is: if something takes
(potentially a long) time to complete (for example reading a value
from a database), they insert a cooperation point to let other threads
run.  Cooperative functions return a value in the Lwt monad
(that is, a value of type <span class="teletype">'a Lwt.t</span> for some type <span class="teletype">'a</span>).
</p><p>In our example, the function <span class="teletype">Lwt_js_events.mouseup</span> may introduce
a cooperation point, because it is unforseeable when this event
happens. That's why it returns a value in the Lwt monad.
</p><p>Using cooperative threads has a huge advantage: as you know precisely
where cooperation points are, <em>you need very few mutexes</em> and you
have <em>very few risks of deadlocks</em>!
</p><p>Using Lwt is very easy and does not cause troubles, provided you never
use <em>blocking functions</em> (non cooperative functions).  <em>Blocking
functions can cause the entre server to hang!</em> Remember:
</p><ul><li> Use the functions from module <span class="teletype">Lwt_unix</span> instead of module
<span class="teletype">Unix</span>,
</li><li> Use cooperative database libraries (like PG'Ocaml for Lwt),
</li><li> If you want to use a non-cooperative function, detach it in another
preemptive thread using <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/api/Lwt_preemptive#VALdetach">Lwt_preemptive.​detach</a></span>,
</li><li> If you want to launch a long-running computation, manually insert
cooperation points using <span class="teletype">Lwt_unix.yield</span>,
</li><li> <span class="teletype">Lwt.bind</span> does not introduce any cooperation point.</li></ul></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Handling events with Lwt</h5></header><p>The module <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Lwt_js_events">Lwt_js_events</a></span>
allows to define event listeners easily using Lwt.
For example <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Lwt_js_events#VALclick">Lwt_js_events.​click</a></span>
takes a DOM element and returns a Lwt thread that will wait until
a click occures on this element.
</p><p>Functions with an ending &quot;s&quot; (<span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Lwt_js_events#VALclicks">Lwt_js_events.​clicks</a></span>, <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Lwt_js_events#VALmousedowns">Lwt_js_events.​mousedowns</a></span>, ...) start again waiting after the handler terminates.
</p><p><span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/api/Lwt#VALpick">Lwt.​pick</a></span> behaves as the first thread in the
list to terminate, and cancels the others.</p></aside><h3>Collaborative drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Client server communication</p></aside><p>In order to see what other users are drawing, we now want to do the following:
</p><ul><li> Send the coordinates to the server when the user draw a line, then
</li><li> Dispatch the coordinates to all connected users.
</li></ul><p>We first declare a type, shared by the server and the client,
describing the color and coordinates of drawn lines.
</p><pre class=""><code class="language-ocaml translatable">{shared{
  type messages = (string * int * (int * int) * (int * int))
    deriving (Json)
}}</code></pre><p>We annotate the type declaration with <span class="teletype">deriving (Json)</span> to allow
type-safe deserialization of this type. Eliom forces you to use this
in order to avoid server crashes if a client sends corrupted data.
This is defined using as <a href="https://github.com/hnrgrgr/deriving" class="ocsimore_phrasing_link">custom
version</a> of the
<a href="http://code.google.com/p/deriving/wiki/Introduction" class="ocsimore_phrasing_link">Deriving syntax
extension</a>.  You need to do that for each type of data sent by the
client to the server.  This annotation can only be added on types
containing exclusively basics type or other types annotated with
deriving. See the Js_of_ocaml API, for more information on the <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Deriving_Json">Deriving_Json</a></span> module.
</p><p>Then we create an Eliom bus to broadcast drawing events to all client
with the function <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_bus#VALcreate">Eliom_bus.​create</a></span>. This function take as parameter the type of
values carried by the bus.
</p><pre class=""><code class="language-ocaml translatable">let bus = Eliom_bus.create Json.t&lt;messages&gt;</code></pre><p>To write draw orders into the bus, we just replace the function
<span class="teletype">line</span> in <span class="teletype">init_client</span> by:
</p><pre class=""><code class="language-ocaml translatable">let line ev =
  let v = compute_line ev in
  let _ = Eliom_bus.write %bus v in
  draw ctx v;
  Lwt.return () in</code></pre><p>Finally, to interpret the draw orders read on the bus, we add the
following line at the end of <span class="teletype">init_handler</span>:
</p><pre class=""><code class="language-ocaml translatable">Lwt.async (fun () -&gt; Lwt_stream.iter (draw ctx) (Eliom_bus.stream %bus))</code></pre><p>Now you can try the program using two browser windows to see that the
lines are drawn on both windows.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Communication channels</h5></header><p>Eliom provides multiple ways for the server to send unsolicited data
to the client:
</p><ul><li> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_bus#TYPEt">Eliom_bus.​t</a></span> are broadcasting channels where
client and server can participate (see also <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/client/Eliom_bus#TYPEt">Eliom_bus.​t</a></span> in the client
api).
</li><li> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_react">Eliom_react</a></span> allows to send
<a href="http://erratique.ch/software/react/doc/React" class="ocsimore_phrasing_link">React events</a> from
the server to the client and conversly.
</li><li> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_comet.Channels#TYPEt">Eliom_comet.​Channels.​t</a></span> are one way communication channels
allowing finer control. It allow sending <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/api/Lwt_stream">Lwt_stream</a></span> to the client.  Eliom_react and Eliom_bus are
implemented over it.
</li></ul><p>It is possible to control the idle behaviour with module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/client/Eliom_comet.Configuration">Eliom_comet.​Configuration</a></span>.</p></aside><h3>Color and size of the brush</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Widgets with OClosure</p></aside><p>In this section, we add a color picker and slider to choose the size
of the brush. For that we used add two widgets provided by the
<span><span class="doclink_error">Error a_manual: exception Projects.No_such_project(&quot;oclosure&quot;)</span></span>.
</p><p>For using OClosure, you have to make sure that it is installed. If you
are using the bundle, it should have been configured with the option
<span class="teletype">--enable-oclosure</span>.  Cf. the
<a href="wiki(36):bundle" class="ocsimore_phrasing_link">corresponding bundle
documentation</a>. Otherwise, you need to install it from
<a href="wiki(33):install" class="ocsimore_phrasing_link">source</a>.
</p><p>In the <span class="teletype">Makefile.options</span>, created by Eliom's distillery, just add <span class="teletype">oclosure</span> to the (currently empty) <span class="teletype">CLIENT_PACKAGES</span>:
</p><pre class="manually-translated"><code class="language-makefile">CLIENT_PACKAGES := oclosure</code></pre><p>To create the widgets, we add the following code in the
<span class="teletype">init_client</span> immediatly after canvas configuration:
</p><pre class=""><code class="language-ocaml translatable">(* Size of the brush *)
let slider = jsnew Goog.Ui.slider(Js.null) in
slider##setMinimum(1.);
slider##setMaximum(80.);
slider##setValue(10.);
slider##setMoveToPointEnabled(Js._true);
slider##render(Js.some Dom_html.document##body);
(* The color palette: *)
let pSmall =
  jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
                           Js.some (Js.string &quot;goog-hsv-palette-sm&quot;))
in
pSmall##render(Js.some Dom_html.document##body);</code></pre><p>And to change the size and the color of the brush, we replace the last
line of the function <span class="teletype">compute_line</span> in <span class="teletype">init_client</span> by:
</p><pre class=""><code class="language-ocaml translatable">let color = Js.to_string (pSmall##getColor()) in
let size = int_of_float (Js.to_float (slider##getValue())) in
(color, size, (oldx, oldy), (!x, !y))</code></pre><p>As last step, we need to add some stylesheets and one JavaScript file
in the headers of our page. To ease the creation of the
<span class="teletype">head</span>-element in HTML we use the function <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_tools.F#VALhead">Eliom_tools.​F.​head</a></span>:
</p><pre class=""><code class="language-ocaml translatable">let page =
  html
    (Eliom_tools.F.head ~title:&quot;Graffiti&quot;
       ~css:[
         [&quot;css&quot;;&quot;common.css&quot;];
         [&quot;css&quot;;&quot;hsvpalette.css&quot;];
         [&quot;css&quot;;&quot;slider.css&quot;];
         [&quot;css&quot;;&quot;graffiti.css&quot;];
         [&quot;graffiti_oclosure.js&quot;];
      ]
      ~js:[ [&quot;graffiti_oclosure.js&quot;] ] ())
    (body [h1 [pcdata &quot;Graffiti&quot;]; canvas_elt])</code></pre><p>You need to install the corresponding stylesheets and images into your
project.  The stylesheet files should go in the directory
<span class="teletype">static/css</span>
</p><ul><li> the <span><a href="/tuto/3.0/manual/files/tutorial/static/css/common.css" class="ocsforge_doclink_tuto">{{{common.css}}}</a></span>
and <span><a href="/tuto/3.0/manual/files/tutorial/static/css/hsvpalette.css" class="ocsforge_doclink_tuto">{{{hsvpalette.css}}}</a></span>
are taken from the Google Closure library;
</li><li> the <span><a href="/tuto/3.0/manual/files/tutorial/static/css/slider.css" class="ocsforge_doclink_tuto">{{{slider.css}}}</a></span>
and <span><a href="/tuto/3.0/manual/files/tutorial/static/css/graffiti.css" class="ocsforge_doclink_tuto">{{{graffiti.css}}}</a></span> are
home-made css; and
</li></ul><p>the following image should go into <span class="monospace">static/images</span>:
</p><ul><li> the <span><a href="/tuto/3.0/manual/files/tutorial/static/images/hsv-sprite-sm.png" class="ocsforge_doclink_tuto">{{{hsv-sprite-sm.png}}}</a></span>
</li></ul><p>Finally, the <span class="teletype">graffiti_oclosure.js</span> script must be generated. To
do this, first, generate the original <span class="teletype">graffiti.js</span> script by
</p><pre class="manually-translated"><code class="language-shell">$ make byte</code></pre><p>Then use <span class="teletype">oclosure_req</span> to generate the Oclosure-specific
<span class="teletype">local/var/www/graffiti/eliom/graffiti_oclosure.js</span> script from
the original
</p><pre class="manually-translated"><code class="language-shell">$ oclosure_req local/var/www/graffiti/eliom/graffiti.js</code></pre><p>Then you can test your application (<span class="teletype">make test.byte</span>).
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>OClosure</h5></header><p>OClosure is a Js_of_ocaml binding for the Google Closure widget
library (used for example in GMail, Google Calendar or Google Maps).
You can use it for building complex user interfaces for your Eliom
application. The full documentation is available <a href="wiki(33):" class="ocsimore_phrasing_link">on the
project's site</a>.</p></aside><h3 id="initial-image"> Sending the initial image <a class="backref" href="#initial-image">&#182;</a></h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services sending other data types</p></aside><p>To finish the first part of the tutorial, we want to save the current
drawing on server side and send the current image when a new user
arrives. To do that, we will use the
<a href="http://www.cairographics.org/cairo-ocaml/" class="ocsimore_phrasing_link">Cairo binding</a> for OCaml.
</p><p>For using Cairo, first, make sure that it is installed. If you are
using the bundle, it should have been configured with the option
<span class="teletype">--enable-cairo</span>. Second, add it to the <span class="teletype">SERVER_PACKAGES</span> in
your <span class="teletype">Makefile.options</span>:
</p><pre class="manually-translated"><code class="language-makefile">SERVER_PACKAGES := cairo2</code></pre><p>The <span class="teletype">draw_server</span> function below is the equivalent of the
<span class="teletype">draw</span> function on the server side and the <span class="teletype">image_string</span>
function outputs the PNG image in a string.
</p><pre class=""><code class="language-ocaml translatable">let rgb_from_string color = (* color is in format &quot;#rrggbb&quot; *)
  let get_color i =
    (float_of_string (&quot;0x&quot;^(String.sub color (1+2*i) 2))) /. 255.
  in
  try get_color 0, get_color 1, get_color 2 with | _ -&gt; 0.,0.,0.

let surface = Cairo.Image.create Cairo.Image.ARGB32 ~width ~height in

let draw_server =
  let ctx = Cairo.create surface in
  (fun ((color : string), size, (x1, y1), (x2, y2)) -&gt;

    (* Set thickness of brush *)
    Cairo.set_line_width ctx (float size) ;
    Cairo.set_line_join ctx Cairo.JOIN_ROUND ;
    Cairo.set_line_cap ctx Cairo.ROUND ;
    let r, g, b =  rgb_from_string color in
    Cairo.set_source_rgb ctx ~r ~g ~b ;

    Cairo.move_to ctx (float x1) (float y1) ;
    Cairo.line_to ctx (float x2) (float y2) ;
    Cairo.Path.close ctx ;

    (* Apply the ink *)
    Cairo.stroke ctx ;
   )

let image_string =
   (fun () -&gt;
     let b = Buffer.create 10000 in
     (* Output a PNG in a string *)
     Cairo.PNG.write_to_stream surface (Buffer.add_string b);
     Buffer.contents b
   )

let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus)</code></pre><p>We also define a service that send the picture:
</p><pre class=""><code class="language-ocaml translatable">let imageservice =
  Eliom_registration.String.register_service
    ~path:[&quot;image&quot;]
    ~get_params:Eliom_parameter.unit
    (fun () () -&gt; Lwt.return (image_string (), &quot;image/png&quot;))</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Eliom_registration</h5></header><p>The module <span class="teletype">Eliom_registration</span> defines several modules with
registration functions for a variety of data types. We have already
seen <span class="teletype">Eliom_registration.Html5</span> and <span class="teletype">Eliom_registration.App</span>.
The module <span class="teletype">Eliom_registration.String</span> sends arbitrary byte output
(represented by an OCaml string). The handler function must return
a pair consisting of the content and the content-type.
</p><p>There are also several other output modules, for example:
</p><ul><li> <span class="teletype">Eliom_registration.File</span> to send static files
</li><li> <span class="teletype">Eliom_registration.Redirection</span> to create a redirection towards another page
</li><li> <span class="teletype">Eliom_registration.Any</span> to create services that decide late what
they want to send
</li><li> <span class="teletype">Eliom_registration.Ocaml</span> to send any OCaml data to be used in a
client side program
</li><li> <span class="teletype">Eliom_registration.Action</span> to create service with no output
(the handler function just performs a side effect on the server)
and reload the current page (or not). We will see an example of actions
in the next chapter.</li></ul></aside><p>We now want to load the initial image once the canvas is created.  Add
the following lines just between the creation of the canvas context and the
creation of the slider:
</p><pre class=""><code class="language-ocaml translatable">(* The initial image: *)
let img =
  Eliom_content.Html5.To_dom.of_img
    (img ~alt:&quot;canvas&quot;
       ~src:(make_uri ~service:%imageservice ())
       ())
in
img##onload &lt;- Dom_html.handler
                (fun ev -&gt; ctx##drawImage(img, 0., 0.); Js._false);</code></pre><p>After compiling the project (<span class="teletype">make byte</span> and the call to
<span class="teletype">oclosure_req</span>), you are ready to try your graffiti-application
by <span class="teletype">make test.byte</span>.
</p><p>Note, that the <span class="teletype">Makefile</span> from the distillery automatically adds
the packages defined in <span class="teletype">SERVER_PACKAGES</span> as an extension in your configuration file <span class="teletype">local/etc/graffiti/graffiti-test.conf</span>:
</p><pre class="manually-translated"><code class="language-xml">&lt;extension findlib-package=&quot;cairo2&quot; /&gt;</code></pre><p>The first version of the program is now complete. You may want now to
install the application by running
</p><pre class="manually-translated"><code class="language-shell">$ make all
$ sudo make install</code></pre><span><a href="/tuto/3.0/manual/files/tutorial.tar.gz" class="ocsforge_doclink_tuto"> Download the code</a></span>.<div class="exercices"><h4>Exercises</h4><ul><li> Add an OClosure button to make possible to download the current
image and save it to the hard disk (reuse the service
<span class="teletype">imageservice</span>).
</li></ul><ul><li> Add an OClosure button with a color picker to select a color from
the drawing. Pressing the button changes the mouse cursor, and disables
current mouse events until the next mouse click event on the document.
Then the color palette changes to the color of the pixel clicked.
(Use the function <span class="teletype">Dom_html.pixel_get</span>).</li></ul></div><p><a href="/tuto/3.0/manual/intro" class="ocsimore_phrasing_link">prev</a>
<a href="/tuto/3.0/manual/interaction" class="ocsimore_phrasing_link">next</a>
</p></div></div></div></body></html>
