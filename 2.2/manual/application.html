<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Writing a client/server Eliom application</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js"></script><script src="/js/client.js"></script></head><body class="tuto 2.2 application"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href="/" class="ocsimore_phrasing_link"><img src="/img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Doc
</p><ul class="mainmenu"><li class="mainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="mainmenu-doc mainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li></ul><div class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc drawermainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href="/ocsigenserver/2.9/manual/quickstart" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href="/ocsigen-toolkit/1.1.0/manual/intro" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-page"><a href="/projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href="/papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href="/credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href="/blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><div class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/2.2/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/2.2/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/2.2/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/2.2/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/2.2/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h2> More coming soon ...</h2></div></nav></div></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><div class="leftcol"><div class="how-versions"><input id="how-versions-toggle" type="checkbox"/><label for="how-versions-toggle" class="how-versions-current">Version 2.2</label><div class="how-versions-all"><a href="/tuto/dev/manual/application">dev</a><a href="/tuto/6.2/manual/application">6.2</a><a href="/tuto/6.1/manual/application">6.1</a><a href="/tuto/6.0/manual/application">6.0</a><a href="/tuto/5.0/manual/application">5.0</a><a href="/tuto/4.2/manual/application">4.2</a><a href="/tuto/4.1/manual/application">4.1</a><a href="/tuto/4.0/manual/application">4.0</a><a href="/tuto/3.0/manual/application">3.0</a><span class="how-versions-all-current">2.2</span><a href="/tuto/2.0/manual/application">2.0</a></div></div><form id="search"><input name="q" id="q" placeholder="search ..."/><button>Search</button></form><div class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/2.2/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/2.2/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/2.2/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/2.2/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/2.2/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h2> More coming soon ...</h2></div></div><div class="rightcol"><header><h1>Writing a client/server Eliom application</h1></header><p><em>The code of this tutorial has been tested with the 2.2 release of
the Ocsigen bundle.</em><br/>
</p><p>In this chapter, we will write a <a href="/graffiti/" class="ocsimore_phrasing_link">collaborative
drawing application</a>.  It is a client/server Web application
displaying an area where users can draw using the mouse, and see what
other users are drawing. </p>The final code is available <span><a href="/tuto/2.2/manual/files/tutorial.tar.gz" class="ocsforge_doclink_tuto">for download</a></span>.<h2 id="basics"> Basics <a class="backref" href="#basics">&#182;</a></h2><h3>My first page</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services<br/>Configuration file<br/>Static validation of HTML</p></aside><p>Our Web application consists of a single page for now. Let's start by
creating a very basic page.  We define the service that will implement
this page by the following declaration:
</p><pre class=""><code class="language-ocaml translatable">open Lwt
open Eliom_content.Html5.D
open Eliom_service
open Eliom_parameter
open Eliom_registration.Html5

let main_service =
  register_service ~path:[&quot;graff&quot;] ~get_params:unit
    (fun () () -&gt; return (html (head (title (pcdata &quot;Page title&quot;)) [])
                               (body [h1 [pcdata &quot;Graffiti&quot;]])))</code></pre><p>The same, written with fully qualified names (without <span class="teletype">open</span>):
</p><pre class=""><code class="language-ocaml translatable">let main_service =
  Eliom_registration.Html5.register_service
    ~path:[&quot;graff&quot;] 
    ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Lwt.return
        (Eliom_content.Html5.D.html
          (Eliom_content.Html5.D.head (Eliom_content.Html5.D.title
					 (Eliom_content.Html5.D.pcdata &quot;&quot;)) [])
          (Eliom_content.Html5.D.body
	     [Eliom_content.Html5.D.h1
		 [Eliom_content.Html5.D.pcdata &quot;Graffiti&quot;]])))</code></pre><p>Copy one of the two pieces of code above in a file <span class="teletype">graffiti.ml</span>,
then compile it with the following command ; it produce a file called
<span class="teletype">graffiti.cmo</span>.
</p><pre>ocamlfind ocamlc -thread -package eliom.server -c graffiti.ml
</pre><p>Download the configuration file <span><a href="/tuto/2.2/manual/files/tutorial/chapter1/start/graffiti.conf" class="ocsforge_doclink_tuto">graffiti.conf</a></span>, then launch
Ocsigen server, with the following command:
</p><pre>ocsigenserver -c graffiti.conf
</pre><p>Your page is now available at URL <a href="http://localhost:8080/graff" class="ocsimore_phrasing_link"><span class="teletype">http://localhost:8080/graff</span></a>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Services</h5></header><p>Unlike typical Web programming techniques (CGI, PHP, ...), with
Eliom, you don't write one file for each URL, but a single OCaml module
(*.cmo or *.cma) for the whole Web site.
</p><p>The <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_service">Eliom_service</a></span> module allows
to create new entry points to your Web site, called <em>services</em>. In
general, services are attached to a URL and generate a Web page.
Services are represented by OCaml values, through which you must
register a function that will generate a page.
</p><p>The <span class="teletype">~path</span> parameter corresponds to the URL where you want to
attach your service. It is a list of strings.  The value
<code>[&quot;foo&quot;; &quot;bar&quot;]</code> corresponds to the URL
<code>foo/bar</code>.  <code>[&quot;dir&quot;; &quot;&quot;]</code> corresponds to
the URL <code>dir/</code> (that is: the default page of the
directory <code>dir</code>).</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Configuration file</h5></header><p>If you consider the sample configuration file previously provided, it
contains various directives for Ocsigen server (port, log files,
extensions to be loaded, etc.), and something like:
</p><pre>&lt;host&gt;
    &lt;static dir=&quot;/path_to/graffiti&quot; /&gt;
    &lt;eliom module=&quot;/path_to/graffiti.cmo&quot; /&gt;
&lt;/host&gt;
</pre><p>These instructions tell the server to:
</p><ul><li> serve files from the directory <code>/path_to/graffiti</code> if they exist,
</li><li> generate pages from services in the Eliom application
<span class="teletype">graffiti.cmo</span> otherwise.</li></ul></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Static validation of HTML</h5></header><p>There are several ways to create pages for Eliom.  You can generate
pages as strings (as in other Web frameworks).  But we prefer checking
at compile time that the HTML will be correct.  Eliom provides several
modules to do that, either using OcamlDuce (if you have it installed)
or using OCaml's polymorphic variants.  This tutorial is using the
second solution, using the module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D">Eliom_content.​Html5.​D</a></span>. This module defines a
construction function for each HTML5 tag.
</p><p><em>Note that it is also possible to use the usual HTML syntax (see
<span><a class="ocsforge_doclink_tyxml" href="/tyxml/4.1.0/api/Pa_tyxml">Pa_tyxml</a></span>).</em>
</p><p>Ocsigen use the <span><a class="ocsforge_doclink_tyxml" href="/tyxml/dev/manual/intro">TyXML</a></span>
library to build HTML tree.  The TyXML library is very strict and
compels you to respect HTML5 standard (with some limitations). For
example if you write:
</p><pre class=""><code class="language-ocaml translatable">(html
   (head (title (pcdata &quot;&quot;)) [pcdata &quot;&quot;])
   (body [pcdata &quot;Hallo&quot;]))</code></pre><p>You will get the following error message, referring at the end of line 2:
</p><pre>Error: This expression has type ([&gt; `PCDATA ] as 'a) Html5.elt
       but an expression was expected of type Html5_types.head_content_fun Html5.elt
       Type 'a is not compatible with type Html5_types.head_content_fun =
           [ `Base
           | `Command
           | `Link
           | `Meta
           | `Noscript of [ `Link | `Meta | `Style ]
           | `Script
           | `Style ]
       The second variant type does not allow tag(s) `PCDATA
</pre><p>where <span><a class="ocsforge_doclink_tyxml" href="/tyxml/4.1.0/api/Html5_types#TYPEhead_content_fun">Html5_types.​head_content_fun</a></span>
is the type of content allowed inside <span class="teletype">&lt;head&gt;</span> (<span class="teletype">&lt;base&gt;</span>,
<span class="teletype">&lt;command&gt;</span>, <span class="teletype">&lt;link&gt;</span>, <span class="teletype">&lt;meta&gt;</span>, etc.). You see that
<span class="teletype">`PCDATA</span> (i.e. raw text) is not included in this polymorphic
variant type.
</p><p><strong>Another example:</strong> In HTML5, some tags cannot be empty. For example
<span class="teletype">&lt;table&gt;</span>must contain at least one row.  To enforce this, the
<span><a class="ocsforge_doclink_tyxml" href="/tyxml/dev/api/Html5.F#VALtable">Html5.table</a></span> function takes two parameters: the first one is the
first row, the second one is a list containing all the other rows
(same thing for <span class="teletype">&lt;tr&gt;</span>, <span class="teletype">&lt;form&gt;</span>, <span class="teletype">&lt;select&gt;</span>, ...).  This
forces the user to handle the empty list case specially and thus make
the output conform to the recommendation from the W3C.
</p><p><em>Strict typing of HTML may seem arduous initially, but in fact it is
very easy to get used to.  It actually saves a huge amount of
debugging time as you will never have to bother about the validity of
pages afterwards.</em>
</p><p>A more detailed introduction to the construction of HTML5 tree is
available in the <span><a class="ocsforge_doclink_tyxml" href="/tyxml/4.1.0/api/Html5.F">TyXML reference API</a></span>.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Lwt</h5></header><p><strong>Important warning:</strong> All the functions you write must be written in
collaborative manner using Lwt. Lwt is a very convenient way to
implement concurrent programs in OCaml, which is now widely used even
for applications not related to Ocsigen.
</p><p>For now we will just use the <span class="teletype">Lwt.return</span> function as above.  We
will come back later on Lwt programming.  You can also have a look at
the <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/manual/manual">Lwt programming guide</a></span>.</p></aside><h3>Execute parts of the program on the client</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Service sending an application<br/>
Client and server code<br/>
Compiling a Web application with server and client parts<br/>
Calling Javascript methods with Js_of_ocaml<br/></p></aside><p>To create our first service, we used the function <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_registration.Html5#VALregister_service">Eliom_registration.​Html5.​register_service</a></span>, as we
wanted to return HTML5. But actually we want our service to send an
Eliom application.  To do that, we will create our own registration
module by using the functor <span class="teletype">Eliom_registration.App</span>:
</p><pre class=""><code class="language-ocaml translatable">module My_app =
  Eliom_registration.App (struct
      let application_name = &quot;graffiti&quot;
    end)</code></pre><p>It is now possible to use <span class="teletype">MyAppl</span> instead of
<span class="teletype">Eliom_registration.Html5</span> for registering our main service
(now at URL <span class="teletype">/</span>):
</p><pre class=""><code class="language-ocaml translatable">let main_service =
  My_app.register_service ~path:[&quot;&quot;]
    ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (pcdata &quot;Graffiti&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]]) ) )</code></pre><p>We now want to add some OCaml code to be executed by the browser. For
that purpose, Eliom provides a syntax extension to distinguish between
server and client code in the same file. We start by a very basic
program, that will display a message to the user by calling the
Javascript function <span class="teletype">alert</span>. Add the following lines to the
program,
</p><pre class=""><code class="language-ocaml translatable">{client{
  let _ = Dom_html.window##alert(Js.string &quot;Hello&quot;)
}}</code></pre><p>Download the <span><a href="/tuto/2.2/manual/files/tutorial/chapter1/no_oclosure/Makefile" class="ocsforge_doclink_tuto">Makefile</a></span>
and <span><a href="/tuto/2.2/manual/files/tutorial/chapter1/no_oclosure/graffiti.conf" class="ocsforge_doclink_tuto">graffiti.conf</a></span>
files. You may want to adapt the configuration file to set some paths,
especially the directory for static files (see also <span class="teletype">STATICDIR</span> in
the Makefile). It is not necessary (and even not a good idea, for
security reasons) to put <span class="teletype">.ml</span> and <span class="teletype">.cma</span>/<span class="teletype">.cmo</span> in the
static files directory!
</p><p>The default <span class="teletype">Makefile</span> recognizes files using Eliom's syntax extension by
their extension <span class="teletype">.eliom</span> (instead of <span class="teletype">.ml</span>).
Put the new version of our program in a file named <span class="teletype">graffiti.eliom</span>
and compile it by typing:
</p><pre>make
</pre><p>This will generate a file called <span class="teletype">graffiti.cma</span> and another one
called <span class="teletype">graffiti.js</span>. The latter <em>must be placed in the static
file directory</em>. To copy it to its rightful place, type:
</p><pre>make install
</pre><p>And finaly, run Ocsigen server:
</p><pre>ocsigenserver -c graffiti.conf
</pre><p>Your page is now available at URL <span class="teletype">http://localhost:8080/</span>. It
should open an alert box. If not, check that the static file directory
in the configuration file is correct.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client side code</h5></header><p>Eliom's syntax extension implements four kinds of quotations. Three of
them are available at source file toplevel:
</p><ul><li> <span class="teletype"> {client{ ... }} </span> for client side specific code.
</li><li> <span class="teletype"> {server{ ... }} </span> (optional) for server side specific code.
</li><li> <span class="teletype"> {shared{ ... }} </span> for code that will be used both for the server and the client.
</li></ul><p>and the last one is available at the expression level:
</p><ul><li> <span class="teletype"> {{ ... }} </span> for client side event handler.
</li></ul><p>In the default Makefile we automatically split the code, compile the server
part as usual, and compile the client part using <span class="teletype">js_of_ocaml</span>,
to create a Javascript file.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Js_of_ocaml</h5></header><p>The client-side parts of the program are compiled to Javascript by
Js_of_ocaml, which recompiles OCaml bytecode, generating Javascript.
It is easy to bind Javascript libraries to call Javascript functions
from OCaml programs. In the example, we are using the <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Dom_html">Dom_html</a></span> module, which is a binding
to allow the manipulation of an HTML page.
</p><p>Js_of_ocaml is using a syntax extension to call Javascript methods:
</p><ul><li> <span class="teletype">obj##m(a, b, c)</span> to call the method <span class="teletype">m</span> of object <span class="teletype">obj</span>
with parameters <span class="teletype">(a, b, c)</span>
</li><li> <span class="teletype">obj##m</span> to get a property
</li><li> <span class="teletype">obj##m &lt;- e</span> to set a property
</li><li> <span class="teletype">jsnew constr (e1, ..., en)</span> to call a Javascript constructor
</li></ul><p>Find more information in <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/manual/overview">Js_of_ocaml's manual </a></span>.</p></aside><h3>Accessing server side variables on client side code</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Executing client side code after loading a page<br/>
Sharing server side values<br/>
Converting an HTML value to a portion of page (a.k.a. Dom node)<br/>
Manipulating HTML node 'by reference'</p></aside><p>The client side process is not really separated from the server side,
we can access some server variables from client code. For instance:
</p><pre class=""><code class="language-ocaml translatable">let count = ref 0</code></pre><pre class=""><code class="language-ocaml translatable">let main_service =
  My_app.register_service ~path:[&quot;&quot;] ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      let count = incr count; !count in
      Eliom_service.onload {{
        Dom_html.window##alert(Js.string
	  (Printf.sprintf &quot;You came %i times to this page&quot; %count))
      }};
      Lwt.return
        (html
           (head (title (pcdata &quot;Graffiti&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]]) ) )</code></pre><p>Here, we are increasing the reference <span class="teletype">count</span> each time the page
is accessed. When the page is loaded the client execute the event
handler registred with <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_service#VALonload">Eliom_service.​onload</a></span> : this client side code access to the
counter using the syntax extension <span class="teletype">%count</span>, and displays it in a
message box.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Executing code after loading a page</h5></header><p>To execute some code on client side just after loading a page, use
function <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_service#VALonload">Eliom_service.​onload</a></span>.  It takes as parameter an event handler
that you can provide using the syntax <span class="teletype"> {{ ... }} </span>.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Antiquotations: Using server side values in client code</h5></header><p>Client side code can reference copies of server side values using
the <span class="teletype">%variable</span> syntax.  It is currently limited to code
included in <span class="teletype"> {{ ... }} </span> (and not yet available in top level
client code <span class="teletype"> {client{ ... }} </span>). Values sent that way are
weakly type checked: the name of the client side type must match the
server side one.  If you define a type and want it to be available
on both sides, declare it in <span class="teletype"> {shared{ ... }} </span>. See the Eliom
manual, for more information anout the <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/client#syntax%">Eliom's syntax extension </a></span>
and its <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/config#compiling">compilation process</a></span>.</p></aside><p>&gt;&gt;
</p><h2 id="graffiti"> Collaborative drawing application <a class="backref" href="#graffiti">&#182;</a></h2><h3>Drawing on a canvas</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Canvas</p></aside><p>We now want to draw something on the page using an HTML5 canvas. As a
first-step, we define a client-side function called <span class="teletype">draw</span> that
draw a line between two given points in a canvas and we call this
function once in the <span class="teletype">onload</span> event handler to draw an <span style="color:#ffaa33;">orange</span> line. Here is the (full) new version
of the program:
</p><pre class=""><code class="language-ocaml translatable">module My_app =
  Eliom_registration.App (
    struct
      let application_name = &quot;graffiti&quot;
    end)

{shared{
  open Eliom_content
  open Eliom_content.Html5.D
  let width = 700
  let height = 400
}}

{client{
  open Eliom_content
  let draw ctx (color, size, (x1, y1), (x2, y2)) =
    ctx##strokeStyle &lt;- (Js.string color);
    ctx##lineWidth &lt;- float size;
    ctx##beginPath();
    ctx##moveTo(float x1, float y1);
    ctx##lineTo(float x2, float y2);
    ctx##stroke()
}}

let canvas_elt =
  canvas ~a:[a_width width; a_height height]
    [pcdata &quot;your browser doesn't support canvas&quot;]

let page =
  (html
    (head (title (pcdata &quot;Graffiti&quot;)) [])
    (body [h1 [pcdata &quot;Graffiti&quot;];
           canvas_elt] ) )

let onload_handler = {{
  let canvas = Html5.To_dom.of_canvas %canvas_elt in
  let ctx = canvas##getContext (Dom_html._2d_) in
  ctx##lineCap &lt;- Js.string &quot;round&quot;;
  draw ctx (&quot;#ffaa33&quot;, 12, (10, 10), (200, 100))
}}

let main_service =
  My_app.register_service ~path:[&quot;&quot;] ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Eliom_service.onload onload_handler;
      Lwt.return page)</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Javascript datatypes in OCaml</h5></header><p>Note that we use the function <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Js#VALstring">Js.​string</a></span> from the Js_of_ocaml's library to convert an OCaml
string into a JS string.</p></aside><h3>Single user drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Mouse events with arrows</p></aside><p>We now want to catch mouse events to draw lines with the mouse like
with the <em>brush</em> tools of any classical drawing application. One
solution would be to mimic classical Javascript code in OCaml ; for
example by using the function <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Dom_events#VALlisten">Dom_events.​listen</a></span> that is the Js_of_ocaml's equivalent of
<span class="teletype">addEventListener</span>. However, this solution is at least as much
verbose than the Javascript equivalent, hence not
satisfactory. Another idea is to use the expressivity allowed by the
functional part of OCaml to hide the complexity behind a nice
combinator library and dramaticaly reduce the code size. In this
tutorial, we will use the <em>experimental</em> <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows">Event_arrows</a></span> module from the
Js_of_ocaml's library.
</p><aside class="wip"><header><h5>Work in progress</h5></header><p><strong>Warning</strong> The event arrows are an experimental
feature. Feedbacks and suggestions sent to the
<a href="https://sympa.mancoosi.univ-paris-diderot.fr/wws/info/ocsigen" class="ocsimore_phrasing_link">Ocsigen
mailing-list</a> will help to improve the API.</p></aside><p>Replace the <span class="teletype">onload_handler</span> of the previous example by the
following piece of code, then compile and draw !
</p><pre class=""><code class="language-ocaml translatable">let onload_handler = {{

  let canvas = Html5.To_dom.of_canvas %canvas_elt in
  let ctx = canvas##getContext (Dom_html._2d_) in
  ctx##lineCap &lt;- Js.string &quot;round&quot;;

  let x = ref 0 and y = ref 0 in

  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##clientX - x0; y := ev##clientY - y0
  in

  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    (&quot;#ff9933&quot;, 5, (oldx, oldy), (!x, !y))
  in

  let line ev = draw ctx (compute_line ev) in

  let open Event_arrows in
  ignore (run (mousedowns canvas
                 (arr (fun ev -&gt; set_coord ev; line ev) &gt;~&gt;&gt;
                  first [mousemoves Dom_html.document (arr line);
                         mouseup Dom_html.document &gt;~&gt;&gt; (arr line)])) ())
}}</code></pre><p>We use two references <span class="teletype">x</span> and <span class="teletype">y</span> to record the last mouse
position.  The function <span class="teletype">set_coord</span> updates these references from
mouse event data.  The function <span class="teletype">compute_line</span> computes the
coordinates of a line from the initial (old) coordinates to the new
coordinates–the event data sent as a parameter.
</p><p>The last four lines of code, that implements the event handling loop, could be
read as: for each <span class="teletype">mousedown</span> event on the canvas, do
<span class="teletype">set_coord</span> then <span class="teletype">line</span> (this will draw a dot), then
(<span class="teletype">&gt;&gt;&gt;</span>) behave as the <span class="teletype">first</span> of the two following lines to
terminate:
</p><ul><li> For each mousemove event on the document, call <span class="teletype">line</span> (never terminates)
</li><li> If there is a mouseup event on the document, call <span class="teletype">line</span>.
</li></ul><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Handling events with arrows</h5></header><p>The module <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows">Event_arrows</a></span>
allows us to define event listeners easily (using arrows). An arrow
from <span class="teletype">'a</span> to <span class="teletype">'b</span> has type <span class="teletype">('a, 'b) Event_arrows.t</span>.
The operator <span class="teletype">&gt; &gt; &gt;</span> is used to bind the output
of an arrow to the input of the following one.
</p><p>For example <span class="teletype">(mouseup Dom_html.document)</span> is an arrow from
<span class="teletype">'a</span> to <span class="teletype">Dom_html.mouseEvent Js.t</span>.
</p><p>The combinator <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows#VALarr">Event_arrows.​arr</a></span> transforms a function of type <span class="teletype">'a -&gt; 'b</span> into
an arrow of type <span class="teletype">('a, 'b) Event_arrows.t</span>. There is also a
combinator <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows#VALlwt_arr">Event_arrows.​lwt_arr</a></span> to transform a function of type <span class="teletype">'a -&gt; 'b Lwt.t</span>
into an arrow of type <span class="teletype">('a, 'b) Event_arrows.t</span>.
</p><p>Combinators like <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows#VALmousedowns">Event_arrows.​mousedowns</a></span> or <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows#VALmousemoves">Event_arrows.​mousemoves</a></span> (ending by &quot;s&quot;) take as parameters the
target of the event and an arrow that will be called each time the
event occures.
</p><p>The function <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows#VALrun">Event_arrows.​run</a></span>
(of type <span class="teletype">('a, unit) t -&gt; 'a -&gt; canceller</span>) sets up an event
handler. It returns a &quot;canceller&quot; that you can use to cancel it:
</p><pre class=""><code class="language-ocaml translatable">let c = Event_arrows.run ( ... ) in
...
Event_arrows.cancel c</code></pre><p>The combinator <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Event_arrows#VALfirst">Event_arrows.​first</a></span> takes a list of arrows and behaves as the first
to terminate. All the other arrows in the list are cancelled.</p></aside><h3>Collaborative drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Client server communication</p></aside><p>In order to see what other users are drawing, we now want to do the following:
</p><ul><li> Send the coordinates to the server when the user draw a line, then
</li><li> Dispatch the coordinates to all connected users.
</li></ul><p>We first declare a type, shared by the server and the client,
describing the color and coordinates of drawn lines.
</p><pre class=""><code class="language-ocaml translatable">{shared{
  type messages = (string * int * (int * int) * (int * int))
    deriving (Json)
}}</code></pre><p>We annotate the type declaration with <span class="teletype">deriving (Json)</span> to allow
type-safe deserialization of this type. Eliom forces you to use this
in order to avoid server crashes if a client sends corrupted data.
This is defined using as <a href="https://github.com/hnrgrgr/deriving" class="ocsimore_phrasing_link">custom
version</a> of the
<a href="http://code.google.com/p/deriving/wiki/Introduction" class="ocsimore_phrasing_link">Deriving syntax
extension</a>.  You need to do that for each type of data sent by the
client to the server.  This annotation can only be added on types
containing exclusively basics type or other types annotated with
deriving. See the Js_of_ocaml API, for more information on the <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/3.1.0/api/Deriving_Json">Deriving_Json</a></span> module.
</p><p>Then we create an Eliom's bus to broadcast draw orders to each client
with the function <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_bus#VALcreate">Eliom_bus.​create</a></span>. This function take as parameter the type of
values carried by the bus.
</p><pre class=""><code class="language-ocaml translatable">let bus = Eliom_bus.create Json.t&lt;messages&gt;</code></pre><p>To write draw orders into the bus, we just replace the function
<span class="teletype">line</span> of the <span class="teletype">onload_handler</span> by:
</p><pre class=""><code class="language-ocaml translatable">let line ev =
  let v = compute_line ev in
  let _ = Eliom_bus.write %bus v in
  draw ctx v in</code></pre><p>Finally, to interpret the draw orders read on the bus, we add the
following line in the <span class="teletype">onload_handler</span> just before the &quot;arrow
event handler&quot;.
</p><pre class=""><code class="language-ocaml translatable">let _ = Lwt_stream.iter (draw ctx) (Eliom_bus.stream %bus) in</code></pre><p>Now you can try the program using two browser windows to see that the
lines are drawn on both windows.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Communication channels</h5></header><p>Eliom provides multiple ways for the server to send unsolicited data
to the client:
</p><ul><li> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_bus#TYPEt">Eliom_bus.​t</a></span> are broadcasting channels where
client and server can participate (see also <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/client/Eliom_bus#TYPEt">Eliom_bus.​t</a></span> in the client
api).
</li><li> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_react">Eliom_react</a></span> allows to send
<a href="http://erratique.ch/software/react/doc/React" class="ocsimore_phrasing_link">React events</a> from
the server to the client and conversly.
</li><li> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_comet.Channels#TYPEt">Eliom_comet.​Channels.​t</a></span> are one way communication channels
allowing finer control. It allow sending <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/api/Lwt_stream">Lwt_stream</a></span> to the client.  Eliom_react and Eliom_bus are
implemented over it.
</li></ul><p>It is possible to control the idle behaviour with module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/client/Eliom_comet.Configuration">Eliom_comet.​Configuration</a></span>.</p></aside><h3>Color and size of the brush</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Widgets with OClosure</p></aside><p>In this section, we add a color picker and slider to choose the size
of the brush. For that we used add two widgets provided by the
<span><span class="doclink_error">Error a_manual: exception Projects.No_such_project(&quot;oclosure&quot;)</span></span>.
</p><p>For using OClosure, you have to make sure that it is installed. If you are
using the bundle, it should have been configured with the option <span class="monospace">–enable-oclosure</span>.
Cf. the <a href="wiki(36):bundle" class="ocsimore_phrasing_link">corresponding bundle documentation</a>.
</p><p>To create the widgets, we add the following code in the
<span class="teletype">onload_handler</span> immediatly after canvas configuration:
</p><pre class=""><code class="language-ocaml translatable">(* Size of the brush *)
let slider = jsnew Goog.Ui.slider(Js.null) in
slider##setMinimum(1.);
slider##setMaximum(80.);
slider##setValue(10.);
slider##setMoveToPointEnabled(Js._true);
slider##render(Js.some Dom_html.document##body);
(* The color palette: *)
let pSmall =
  jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
                           Js.some (Js.string &quot;goog-hsv-palette-sm&quot;))
in
pSmall##render(Js.some Dom_html.document##body);</code></pre><p>And to change the size and the color of the brush, we replace the last
line of the function <span class="teletype">compute_line</span> of the <span class="teletype">onload_handler</span>
by:
</p><pre class=""><code class="language-ocaml translatable">let color = Js.to_string (pSmall##getColor()) in
let size = int_of_float (Js.to_float (slider##getValue())) in
(color, size, (oldx, oldy), (!x, !y))</code></pre><p>As last step, we need to add some stylesheets and one JS file in the
headers of our page:
</p><pre class=""><code class="language-ocaml translatable">let page =
  html
    (head
       (title (pcdata &quot;Graffiti&quot;))
       [ css_link
	   ~uri:(make_uri (Eliom_service.static_dir ())
		  [&quot;css&quot;;&quot;common.css&quot;]) ();
	 css_link
	   ~uri:(make_uri (Eliom_service.static_dir ())
		  [&quot;css&quot;;&quot;hsvpalette.css&quot;]) ();
	 css_link
	   ~uri:(make_uri (Eliom_service.static_dir ())
		  [&quot;css&quot;;&quot;slider.css&quot;]) ();
	 css_link
	   ~uri:(make_uri (Eliom_service.static_dir ())
		  [&quot;css&quot;;&quot;graffiti.css&quot;]) ();
	 js_script
	   ~uri:(make_uri  (Eliom_service.static_dir ())
		  [&quot;graffiti_oclosure.js&quot;]) ();
       ])
    (body [h1 [pcdata &quot;Graffiti&quot;]; canvas_elt])</code></pre><aside class="wip"><header><h5>Work in progress</h5></header><p>The previous code will not work with Eliom ≤ 2.0.1. With those
versions, the function <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D#VALmake_uri">Eliom_content.​Html5.​D.​make_uri</a></span> could not be used outside a service
handler. To delay the URI calculation you need to replace the constant
<span class="teletype">page</span> with a function that take <span class="teletype">unit</span> and returns the page.
</p><pre class=""><code class="language-ocaml translatable">let page () =
  html (head ...) (body ...)

...

My_app.register_service ~path:[&quot;&quot;] ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Eliom_service.onload onload_handler;
      Lwt.return (page ()))</code></pre><p>In the upcoming release, the URI is not immediatly computed by the
<span class="teletype">make_uri</span> function but computed each time the page is sent to the
client. This allow the definition of &quot;global&quot; nodes outsides of
service handler and still use relative URI.</p></aside><p>You need to install the corresponding stylesheets and images into your project:
</p><p>The stylesheet files should go in the directory <span class="monospace">static/css</span>:
</p><ul><li> the <span><a href="/tuto/2.2/manual/files/tutorial/static/css/common.css" class="ocsforge_doclink_tuto">{{{common.css}}}</a></span>
and <span><a href="/tuto/2.2/manual/files/tutorial/static/css/hsvpalette.css" class="ocsforge_doclink_tuto">{{{hsvpalette.css}}}</a></span>
are taken from the Google Closure library;
</li><li> the <span><a href="/tuto/2.2/manual/files/tutorial/static/css/slider.css" class="ocsforge_doclink_tuto">{{{slider.css}}}</a></span>
and <span><a href="/tuto/2.2/manual/files/tutorial/static/css/graffiti.css" class="ocsforge_doclink_tuto">{{{graffiti.css}}}</a></span> are
home-made css; and
</li></ul><p>the following image should go into <span class="monospace">static/images</span>:
</p><ul><li> the <span><a href="/tuto/2.2/manual/files/tutorial/static/images/hsv-sprite-sm.png" class="ocsforge_doclink_tuto">{{{hsv-sprite-sm.png}}}</a></span>
</li></ul><p>Finally, the <span class="teletype">graffiti_oclosure.js</span> script is generated according to the
<span class="teletype">graffiti.js</span> with the following command:
</p><pre>oclosure_req graffiti.js
</pre><p>Using the example <span><a href="/tuto/2.2/manual/files/tutorial/chapter1/with_oclosure/Makefile" class="ocsforge_doclink_tuto">{{{Makefile}}}</a></span> all
those static files are generated and installed by the <span class="teletype">install</span>
rule in the configured static directory (see the <span class="teletype">STATICDIR</span>
variable).
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>OClosure</h5></header><p>OClosure is a Js_of_ocaml binding for the Google Closure widget
library (used for example in GMail, Google Calendar or Google Maps).
You can use it for building complex user interfaces for your Eliom
application. The full documentation is available <a href="wiki(33):" class="ocsimore_phrasing_link">on the
project's site</a>.</p></aside><h3 id="initial-image"> Sending the initial image <a class="backref" href="#initial-image">&#182;</a></h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services sending other data types</p></aside><p>To finish the first part of the tutorial, we want to save the current
drawing on server side and send the current image when a new user
arrives. To do that, we will use the
<a href="http://www.cairographics.org/cairo-ocaml/" class="ocsimore_phrasing_link">Cairo binding</a> for OCaml.
</p><p>For using Cairo, make sure that it is installed. If you are using the bundle,
it should have been configured with the option <span class="monospace">–enable-cairo</span>.
</p><p>The <span class="teletype">draw_server</span> function below is the equivalent of the
<span class="teletype">draw</span> function on the server side and the <span class="teletype">image_string</span>
function outputs the PNG image in a string.
</p><aside class="wip"><header><h5>Work in progress</h5></header><p>In an ideal world, we would have a common interface for HTML5 canvas
and the Cairo binding, so that we could share the code between
<span class="teletype">draw_server</span> and <span class="teletype">draw</span>.</p></aside><pre class=""><code class="language-ocaml translatable">let rgb_from_string color = (* color is in format &quot;#rrggbb&quot; *)
  let get_color i =
    (float_of_string (&quot;0x&quot;^(String.sub color (1+2*i) 2))) /. 255.
  in
  try get_color 0, get_color 1, get_color 2 with | _ -&gt; 0.,0.,0.

let draw_server, image_string =
  let surface =
    Cairo.image_surface_create Cairo.FORMAT_ARGB32 ~width ~height
  in
  let ctx = Cairo.create surface in
  ((fun ((color : string), size, (x1, y1), (x2, y2)) -&gt;

    (* Set thickness of brush *)
    Cairo.set_line_width ctx (float size) ;
    Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
    Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
    let red, green, blue =  rgb_from_string color in
    Cairo.set_source_rgb ctx ~red ~green ~blue ;

    Cairo.move_to ctx (float x1) (float y1) ;
    Cairo.line_to ctx (float x2) (float y2) ;
    Cairo.close_path ctx ;

    (* Apply the ink *)
    Cairo.stroke ctx ;
   ),
   (fun () -&gt;
     let b = Buffer.create 10000 in
     (* Output a PNG in a string *)
     Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
     Buffer.contents b
   ))

let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus)</code></pre><p>We also define a service that send the picture:
</p><pre class=""><code class="language-ocaml translatable">let imageservice =
  Eliom_registration.String.register_service
    ~path:[&quot;image&quot;]
    ~get_params:Eliom_parameter.unit
    (fun () () -&gt; Lwt.return (image_string (), &quot;image/png&quot;))</code></pre><aside class="wip"><header><h5>Work in progress</h5></header><p>With Eliom ≤ 2.0.1, the module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_registration.String">Eliom_registration.​String</a></span> was named <span><a class="ocsforge_doclink_eliom" href="/eliom/2.0.1/api/server/Eliom_registration.Text">Eliom_registration.​Text</a></span>.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Eliom_registration</h5></header><p>The module <span class="teletype">Eliom_registration</span> defines several modules with
registration functions for a variety of data types. We have already
seen <span class="teletype">Eliom_registration.Html5</span> and <span class="teletype">Eliom_registration.App</span>.
The module <span class="teletype">Eliom_registration.String</span> sends any byte output
(represented with an OCaml string). The handler function must return
a pair consisting of the content and the content-type.
</p><p>There are also several other output modules, for example:
</p><ul><li> <span class="teletype">Eliom_registration.Files</span> to send static files
</li><li> <span class="teletype">Eliom_registration.Redirection</span> to create a redirection towards another page
</li><li> <span class="teletype">Eliom_registration.Any</span> to create services that choose themselves what
they want to send
</li><li> <span class="teletype">Eliom_registration.Ocaml</span> to send any OCaml data to be used in a
client side program
</li><li> <span class="teletype">Eliom_registration.Action</span> to create service with no output
(the handler function just performs a side effect on the server)
and reload the current page (or not). We will see an example of actions
in the next chapter.</li></ul></aside><p>We now want to load the initial image once the canvas is created.  Add
the following lines just between the creation of the canvas context and the
creation of the slider:
</p><pre class=""><code class="language-ocaml translatable">(* The initial image: *)
let img =
  Html5.To_dom.of_img
    (img ~alt:&quot;canvas&quot;
       ~src:(make_uri ~service:%imageservice ())
       ())
in
img##onload &lt;- Dom_html.handler
                (fun ev -&gt; ctx##drawImage(img, 0., 0.); Js._false);</code></pre><p>This new version of the <span class="teletype">graffiti.cma</span> module now depends on
<span class="teletype">cairo</span>. We must ask <span class="teletype">ocsigenserver</span> to load <span class="teletype">cairo</span>
before loading <span class="teletype">graffiti.cma</span>. This is done by adding the
following line in the configuration file.
</p><pre>&lt;extension findlib-package=&quot;cairo&quot; /&gt;
</pre><p>The first version of the program is now complete. </p><span><a href="/tuto/2.2/manual/files/tutorial.tar.gz" class="ocsforge_doclink_tuto"> Download the code</a></span>.<div class="exercices"><h4>Exercises</h4><ul><li> Add an OClosure button to make possible to download the current
image and save it to the hard disk (reuse the service
<span class="teletype">imageservice</span>).
</li></ul><ul><li> Add an OClosure button with a color picker to select a color from
the drawing. Pressing the button changes the mouse cursor, and disables
current mouse events until the next mouse click event on the document.
Then the color palette changes to the color of the pixel clicked.
(Use the function <span class="teletype">Dom_html.pixel_get</span>).</li></ul></div></div></div></div></body></html>
