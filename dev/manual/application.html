<html><head><title>Writing a client/server Eliom application</title><meta charset="utf8"/><link rel="stylesheet" href="https://ocsigen.org/tuto/tmp/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script type="text/javascript" src="https://ocsigen.org/js/client.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js">
//<![CDATA[

//]]>
</script></head><body><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href=".././../../" class="ocsimore_phrasing_link"><img src=".././../../img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><div class="mainmenu"><p><span class="mainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a></span>
<span class="mainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a></span>
</p><p><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a></p><p><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a></p><p><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a></p><p><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a></p><p><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a></p></div><form id="googlesearch" action="https://google.com/search"><input name="q" id="gsearch-box" placeholder="Search using Google"/><label for="gsearch-box"><img src="https://ocsigen.org/tuto/tmp/search.svg" alt="" id="gsearch-icon"/></label><input type="submit" id="gsearch-submit" onclick="document.getElementById('gsearch-box').value += ' site:ocsigen.org';"/></form><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-toolkit/" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-page"><a href=".././../../projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href=".././../../papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href=".././../../credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href=".././../../blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h1> Main tutorial</h1><h2><a href="intro" class="ocsimore_phrasing_link">Introduction. Ocsigen: where to start?</a></h2><h2><a href="start" class="ocsimore_phrasing_link">Your first app in 5 minutes</a></h2><h2><a href="basicwebsite" class="ocsimore_phrasing_link">A basic Web site in OCaml</a></h2><h2><a href="tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client-server widgets</a></h2><h2><a href="application" class="ocsimore_phrasing_link">Client/server application: Graffiti</a></h2><h2><a href="how-to-register-session-data" class="ocsimore_phrasing_link">Session data: Eliom references</a></h2><h2><a href="interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="tutoreact" class="ocsimore_phrasing_link">Reactive client-server Web applications</a></h2><h2><a href="misc" class="ocsimore_phrasing_link">Mixing traditional Web interaction with client-server app</a></h2><h1> 5-minute tutorials</h1><h2><a href="lwt" class="ocsimore_phrasing_link">Lwt</a></h2><h2><a href="html" class="ocsimore_phrasing_link">HTML</a></h2><h1> Other tutorials: Miscellanous features</h1><h2><a href="mobile" class="ocsimore_phrasing_link">Mobile applications with Ocsigen</a></h2><h2><a href="custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="rest" class="ocsimore_phrasing_link">RESTful JSON API</a></h2><h2><a href="ocsipersist" class="ocsimore_phrasing_link">Persistent tables with Ocsipersist</a></h2><h2><a href="hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h2><h2><a href="macaque" class="ocsimore_phrasing_link">MaCaQue: SQL queries - Users</a></h2><h1> Improving Graffiti</h1><h2><a href="pictures" class="ocsimore_phrasing_link">Download pictures</a></h2><h2><a href="music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="reactivemediaplayer" class="ocsimore_phrasing_link">Reactive media player</a></h2><h1 class="howto"> HOW-TO</h1><h2> My first steps with Ocsigen</h2><h3><a href="how-to-install-ocsigen" class="ocsimore_phrasing_link">How to install Ocsigen</a></h3><h3><a href="how-to-make-hello-world-in-ocsigen" class="ocsimore_phrasing_link">How to make &quot;hello world&quot; in Ocsigen</a></h3><h3><a href="how-to-compile-my-ocsigen-pages" class="ocsimore_phrasing_link">How to compile my Ocsigen pages</a></h3><h3><a href="how-to-configure-and-launch-the-ocsigen-server" class="ocsimore_phrasing_link">How to configure and launch the Ocsigen Server</a></h3><h3><a href="how-does-a-page-s-source-code-look" class="ocsimore_phrasing_link">How does a client-server app source code look like?</a></h3><h2> How to put some elements in my page ?</h2><h3><a href="how-to-make-page-a-skeleton" class="ocsimore_phrasing_link">How to make a page skeleton</a></h3><h3><a href="how-to-use-get-parameters-or-parameters-in-the-url" class="ocsimore_phrasing_link">How to use GET parameters (parameters in the URL)</a></h3><h3><a href="how-to-add-css-stylesheet" class="ocsimore_phrasing_link">How to add CSS stylesheet</a></h3><h3><a href="how-to-add-a-javascript-script" class="ocsimore_phrasing_link">How to add a Javascript script</a></h3><h3><a href="how-to-add-a-div" class="ocsimore_phrasing_link">How to add a div</a></h3><h3><a href="how-to-add-a-list" class="ocsimore_phrasing_link">How to add lists in pages?</a></h3><h3><a href="how-to-add-an-image" class="ocsimore_phrasing_link">How to add an image</a></h3><h3><a href="how-to-write-titles-and-paragraphs" class="ocsimore_phrasing_link">How to write titles and paragraphs</a></h3><h3><a href="how-to-set-and-id-classes-or-other-attributes-to-html-elements" class="ocsimore_phrasing_link">How to set and id, classes or other attributes to HTML elements</a></h3><h3><a href="how-to-add-a-select-or-other-form-element" class="ocsimore_phrasing_link">How to add select (or other form element)</a></h3><h3><a href="how-to-insert-raw-form-elements-not-belonging-to-a-form-towards-a-service" class="ocsimore_phrasing_link">How to insert &quot;raw&quot; form elements (not belonging to a form towards a service)</a></h3><h3><a href="how-to-make-responsive-css" class="ocsimore_phrasing_link">How to make responsive CSS</a></h3><h2> Services</h2><h3><a href="how-to-do-links-to-other-pages" class="ocsimore_phrasing_link">How to do links to other pages</a></h3><h3><a href="how-to-write-forms" class="ocsimore_phrasing_link">How to write forms</a></h3><h3><a href="how-to-register-a-service-that-decides-itself-what-to-send" class="ocsimore_phrasing_link">How to register a service that decides itself what to send</a></h3><h3><a href="how-to-create-link-to-a-current-page-without-knowing-its-url" class="ocsimore_phrasing_link">How to create link to a current page (without knowing its URL)</a></h3><h3><a href="how-to-create-form-wizard-sequence-of-pages-depending-on-data-entered-on-previous-ones" class="ocsimore_phrasing_link">How to create form wizard (sequence of pages depending on data entered on previous ones)</a></h3><h3><a href="how-to-write-a-json-service" class="ocsimore_phrasing_link">How to write a JSON service</a></h3><h3><a href="how-to-send-file-download" class="ocsimore_phrasing_link">How to send a file (download)</a></h3><h3><a href="how-to-send-file-upload" class="ocsimore_phrasing_link">How to send a file (upload)</a></h3><h2> Js_of_ocaml</h2><h3><a href="how-to-attach-ocaml-values-to-dom-elements" class="ocsimore_phrasing_link">How to attach OCaml values to DOM elements</a></h3><h3><a href="how-to-know-whether-the-browser-window-has-the-focus-or-not" class="ocsimore_phrasing_link">How to know whether the browser window has the focus or not</a></h3><h3><a href="how-to-build-js-object" class="ocsimore_phrasing_link">How to build js object</a></h3><h3><a href="how-to-stop-default-behaviour-of-events" class="ocsimore_phrasing_link">How to stop default behaviour of events</a></h3><h3><a href="how-to-call-an-ocaml-function-from-js-code" class="ocsimore_phrasing_link">How to call an OCaml function from js code</a></h3><h2> Eliom client-server applications</h2><h3><a href="how-to-call-a-server-side-function-from-client-side" class="ocsimore_phrasing_link">How to call a server-side function from the client side</a></h3><h3><a href="how-to-make-the-client-side-program-get-an-html-element-from-the-server-and-insert-it-in-the-page" class="ocsimore_phrasing_link">How to make the client side program get an HTML element from the server and insert it in the page</a></h3><h3><a href="how-to-attach-ocaml-values-to-the-html-nodes-sent-to-the-client" class="ocsimore_phrasing_link">How to attach OCaml values to the HTML nodes sent to the client</a></h3><h3><a href="how-to-iterate-on-all-sessions-for-one-user-or-all-tabs" class="ocsimore_phrasing_link">How to iterate on all sessions for one user, or all tabs</a></h3><h3><a href="how-to-implement-a-notification-system" class="ocsimore_phrasing_link">How to implement a notification system</a></h3><h3><a href="how-to-send-a-file-to-server-without-stopping-the-client-process" class="ocsimore_phrasing_link">How to send a file to server without stopping the client process</a></h3><h3><a href="how-to-detect-channel-disconnection" class="ocsimore_phrasing_link">How to detect channel disconnection</a></h3><h3><a href="how-to-detect-on-client-side-that-the-server-side-state-for-the-process-is-closed" class="ocsimore_phrasing_link">How to detect on client side that the server side state for the process is closed</a></h3><h2> Database</h2><h3><a href="how-to-use-a-database-with-eliom" class="ocsimore_phrasing_link">How to use a database with Eliom</a></h3><h2> Eliom Server side</h2><h3><a href="how-do-i-create-a-cryptographically-safe-identifier" class="ocsimore_phrasing_link">How do I create a Cryptographically safe identifier</a></h3></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol">Version <select class="how-versions" onchange="location = this.value;"><option value=".././../2.0/manual/application">2.0</option><option value=".././../2.2/manual/application">2.2</option><option value=".././../3.0/manual/application">3.0</option><option value=".././../4.0/manual/application">4.0</option><option value=".././../4.1/manual/application">4.1</option><option value=".././../4.2/manual/application">4.2</option><option value=".././../5.0/manual/application">5.0</option><option value=".././../6.0/manual/application">6.0</option><option value=".././../6.1/manual/application">6.1</option><option value=".././../6.2/manual/application">6.2</option><option value=".././../dev/manual/application" selected="selected">dev</option></select><nav class="how-doctree"><h1> Main tutorial</h1><h2><a href="intro" class="ocsimore_phrasing_link">Introduction. Ocsigen: where to start?</a></h2><h2><a href="start" class="ocsimore_phrasing_link">Your first app in 5 minutes</a></h2><h2><a href="basicwebsite" class="ocsimore_phrasing_link">A basic Web site in OCaml</a></h2><h2><a href="tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client-server widgets</a></h2><h2><a href="application" class="ocsimore_phrasing_link">Client/server application: Graffiti</a></h2><h2><a href="how-to-register-session-data" class="ocsimore_phrasing_link">Session data: Eliom references</a></h2><h2><a href="interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="tutoreact" class="ocsimore_phrasing_link">Reactive client-server Web applications</a></h2><h2><a href="misc" class="ocsimore_phrasing_link">Mixing traditional Web interaction with client-server app</a></h2><h1> 5-minute tutorials</h1><h2><a href="lwt" class="ocsimore_phrasing_link">Lwt</a></h2><h2><a href="html" class="ocsimore_phrasing_link">HTML</a></h2><h1> Other tutorials: Miscellanous features</h1><h2><a href="mobile" class="ocsimore_phrasing_link">Mobile applications with Ocsigen</a></h2><h2><a href="custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="rest" class="ocsimore_phrasing_link">RESTful JSON API</a></h2><h2><a href="ocsipersist" class="ocsimore_phrasing_link">Persistent tables with Ocsipersist</a></h2><h2><a href="hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h2><h2><a href="macaque" class="ocsimore_phrasing_link">MaCaQue: SQL queries - Users</a></h2><h1> Improving Graffiti</h1><h2><a href="pictures" class="ocsimore_phrasing_link">Download pictures</a></h2><h2><a href="music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="reactivemediaplayer" class="ocsimore_phrasing_link">Reactive media player</a></h2><h1 class="howto"> HOW-TO</h1><h2> My first steps with Ocsigen</h2><h3><a href="how-to-install-ocsigen" class="ocsimore_phrasing_link">How to install Ocsigen</a></h3><h3><a href="how-to-make-hello-world-in-ocsigen" class="ocsimore_phrasing_link">How to make &quot;hello world&quot; in Ocsigen</a></h3><h3><a href="how-to-compile-my-ocsigen-pages" class="ocsimore_phrasing_link">How to compile my Ocsigen pages</a></h3><h3><a href="how-to-configure-and-launch-the-ocsigen-server" class="ocsimore_phrasing_link">How to configure and launch the Ocsigen Server</a></h3><h3><a href="how-does-a-page-s-source-code-look" class="ocsimore_phrasing_link">How does a client-server app source code look like?</a></h3><h2> How to put some elements in my page ?</h2><h3><a href="how-to-make-page-a-skeleton" class="ocsimore_phrasing_link">How to make a page skeleton</a></h3><h3><a href="how-to-use-get-parameters-or-parameters-in-the-url" class="ocsimore_phrasing_link">How to use GET parameters (parameters in the URL)</a></h3><h3><a href="how-to-add-css-stylesheet" class="ocsimore_phrasing_link">How to add CSS stylesheet</a></h3><h3><a href="how-to-add-a-javascript-script" class="ocsimore_phrasing_link">How to add a Javascript script</a></h3><h3><a href="how-to-add-a-div" class="ocsimore_phrasing_link">How to add a div</a></h3><h3><a href="how-to-add-a-list" class="ocsimore_phrasing_link">How to add lists in pages?</a></h3><h3><a href="how-to-add-an-image" class="ocsimore_phrasing_link">How to add an image</a></h3><h3><a href="how-to-write-titles-and-paragraphs" class="ocsimore_phrasing_link">How to write titles and paragraphs</a></h3><h3><a href="how-to-set-and-id-classes-or-other-attributes-to-html-elements" class="ocsimore_phrasing_link">How to set and id, classes or other attributes to HTML elements</a></h3><h3><a href="how-to-add-a-select-or-other-form-element" class="ocsimore_phrasing_link">How to add select (or other form element)</a></h3><h3><a href="how-to-insert-raw-form-elements-not-belonging-to-a-form-towards-a-service" class="ocsimore_phrasing_link">How to insert &quot;raw&quot; form elements (not belonging to a form towards a service)</a></h3><h3><a href="how-to-make-responsive-css" class="ocsimore_phrasing_link">How to make responsive CSS</a></h3><h2> Services</h2><h3><a href="how-to-do-links-to-other-pages" class="ocsimore_phrasing_link">How to do links to other pages</a></h3><h3><a href="how-to-write-forms" class="ocsimore_phrasing_link">How to write forms</a></h3><h3><a href="how-to-register-a-service-that-decides-itself-what-to-send" class="ocsimore_phrasing_link">How to register a service that decides itself what to send</a></h3><h3><a href="how-to-create-link-to-a-current-page-without-knowing-its-url" class="ocsimore_phrasing_link">How to create link to a current page (without knowing its URL)</a></h3><h3><a href="how-to-create-form-wizard-sequence-of-pages-depending-on-data-entered-on-previous-ones" class="ocsimore_phrasing_link">How to create form wizard (sequence of pages depending on data entered on previous ones)</a></h3><h3><a href="how-to-write-a-json-service" class="ocsimore_phrasing_link">How to write a JSON service</a></h3><h3><a href="how-to-send-file-download" class="ocsimore_phrasing_link">How to send a file (download)</a></h3><h3><a href="how-to-send-file-upload" class="ocsimore_phrasing_link">How to send a file (upload)</a></h3><h2> Js_of_ocaml</h2><h3><a href="how-to-attach-ocaml-values-to-dom-elements" class="ocsimore_phrasing_link">How to attach OCaml values to DOM elements</a></h3><h3><a href="how-to-know-whether-the-browser-window-has-the-focus-or-not" class="ocsimore_phrasing_link">How to know whether the browser window has the focus or not</a></h3><h3><a href="how-to-build-js-object" class="ocsimore_phrasing_link">How to build js object</a></h3><h3><a href="how-to-stop-default-behaviour-of-events" class="ocsimore_phrasing_link">How to stop default behaviour of events</a></h3><h3><a href="how-to-call-an-ocaml-function-from-js-code" class="ocsimore_phrasing_link">How to call an OCaml function from js code</a></h3><h2> Eliom client-server applications</h2><h3><a href="how-to-call-a-server-side-function-from-client-side" class="ocsimore_phrasing_link">How to call a server-side function from the client side</a></h3><h3><a href="how-to-make-the-client-side-program-get-an-html-element-from-the-server-and-insert-it-in-the-page" class="ocsimore_phrasing_link">How to make the client side program get an HTML element from the server and insert it in the page</a></h3><h3><a href="how-to-attach-ocaml-values-to-the-html-nodes-sent-to-the-client" class="ocsimore_phrasing_link">How to attach OCaml values to the HTML nodes sent to the client</a></h3><h3><a href="how-to-iterate-on-all-sessions-for-one-user-or-all-tabs" class="ocsimore_phrasing_link">How to iterate on all sessions for one user, or all tabs</a></h3><h3><a href="how-to-implement-a-notification-system" class="ocsimore_phrasing_link">How to implement a notification system</a></h3><h3><a href="how-to-send-a-file-to-server-without-stopping-the-client-process" class="ocsimore_phrasing_link">How to send a file to server without stopping the client process</a></h3><h3><a href="how-to-detect-channel-disconnection" class="ocsimore_phrasing_link">How to detect channel disconnection</a></h3><h3><a href="how-to-detect-on-client-side-that-the-server-side-state-for-the-process-is-closed" class="ocsimore_phrasing_link">How to detect on client side that the server side state for the process is closed</a></h3><h2> Database</h2><h3><a href="how-to-use-a-database-with-eliom" class="ocsimore_phrasing_link">How to use a database with Eliom</a></h3><h2> Eliom Server side</h2><h3><a href="how-do-i-create-a-cryptographically-safe-identifier" class="ocsimore_phrasing_link">How do I create a Cryptographically safe identifier</a></h3></nav></nav><article class="rightcol"><header><h1>Writing a client/server Eliom application</h1></header><p><em>The code of this tutorial has been tested against Eliom 6.0.</em> <br/>
</p><p>In this chapter, we will write a <a href=".././../../graffiti/" class="ocsimore_phrasing_link">collaborative
drawing application</a>. It is a client/server web application
displaying an area where users can draw using the mouse, and see what
other users are drawing at the same time and in real-time.
</p><p>This tutorial is a good starting point if you want a step-by-step
introduction to Eliom programming.
</p>The final eliom code is available
<a href="https://github.com/ocsigen/graffiti/tree/master/simple" class="ocsimore_phrasing_link">for download</a>.
<a href="https://github.com/ocsigen/graffiti/releases/tag/eliom-5.0" class="ocsimore_phrasing_link">Tag eliom-5.0</a>
has been tested against Eliom 5.0.<h2 id="basics"> Basics <a class="backref" href="#basics">&#182;</a></h2><p>To get started, we recommend using <span><a href=".././../../eliom/latest/manual/workflow-distillery">Eliom's distillery</a></span>, a program which
creates scaffolds for Eliom projects. The following command creates a
very simple project called <span class="teletype">graffiti</span> in the directory
<span class="teletype">graffiti</span>:
</p><pre class="manually-translated"><code class="language-shell">$ eliom-distillery -name graffiti -template basic.ppx -target-directory graffiti</code></pre><h3>My first page</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services<br/>Configuration file<br/>Static validation of HTML</p></aside><p>Our web application consists of a single page for now. Let's start by
creating a very basic page. We define the service that will implement
this page by the following declaration:
</p><pre class="server" class=""><code class="language-ocaml translatable">open Eliom_content.Html.D (* provides functions to create HTML nodes *)

let main_service =
  Eliom_registration.Html.create
    ~path:(Eliom_service.Path [&quot;graff&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (pcdata &quot;Page title&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]])))</code></pre><p>If you're using <span class="teletype">eliom-distillery</span> just replace the content of the
eliom-file by the above lines and run
</p><pre class="manually-translated"><code class="language-shell">$ make test.byte</code></pre><p>This will compile your application and run <span class="teletype">ocsigenserver</span> on it.
(Refer to the <span><a href=".././../../eliom/latest/manual/workflow-compilation">manual</a></span> on how to compile your project
&quot;by hand&quot;.)
</p><p>Your page is now available at URL <a href="http://localhost:8080/graff" class="ocsimore_phrasing_link"><span class="teletype">http://localhost:8080/graff</span></a>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Services</h5></header><p>Unlike typical web programming techniques (CGI, PHP, ...), with Eliom
you do not need to write one file per URL. The application can be
split into multiple files as per the developer's style. What matters
is that you eventually produce a single module (*.cmo or *.cma) for
the whole website.
</p><p>The module <span><a href=".././../../eliom/latest/api/Eliom_service">Eliom_service</a></span> allows to
create new entry points to your web site, called <em>services</em>. In
general, services are attached to a URL and generate a web page.
Services are represented by OCaml values, through which you must
register a function that will generate a page.
</p><p>The <span class="teletype">~path</span> parameter corresponds to the URL where you want to
attach your service. It is a list of strings.  The value
<code>[&quot;foo&quot;; &quot;bar&quot;]</code> corresponds to the URL
<code>foo/bar</code>.  <code>[&quot;dir&quot;; &quot;&quot;]</code> corresponds to
the URL <code>dir/</code> (that is: the default page of the
directory <code>dir</code>).</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Configuration file</h5></header><p>In the directory of the project created by the Eliom-distillery, you
can find the file <span class="teletype">graffiti.conf.in</span>. This file is used in
conjunction with the variables in <span class="teletype">Makefile.options</span> to generate
the <span class="teletype">ocsigenserver</span> configuration file.
</p><p>Once you start up your application via <span class="teletype">make test.byte</span>, the
configuration file becomes available at
<span class="teletype">local/etc/graffiti/graffiti-test.conf</span>. It contains various
directives for Ocsigen server (port, log files, extensions to be
loaded, etc.), taken from <span class="teletype">Makefile.options</span>, and something like:
</p><pre>&lt;host&gt;
  &lt;static dir=&quot;static&quot; /&gt;
  &lt;eliommodule module=&quot;/path_to/graffiti.cma&quot; /&gt;
  &lt;eliom /&gt;
&lt;/host&gt;
</pre><p><span class="teletype">&lt;eliommodule ... /&gt;</span> asks the server to load Eliom module
<span class="teletype">graffiti.cma</span>, containing the Eliom application,
at startup and attach it to this host (and site).
</p><p>Extensions <span class="teletype">&lt;static ... /&gt;</span> (staticmod) and <span class="teletype">&lt;eliom /&gt;</span>
are called successively:
</p><ul><li> If they exist, files from the directory <code>/path_to/graffiti/static</code> will be served,
</li><li> Otherwise, Server will try to generate pages with Eliom
(<span class="teletype">&lt;eliom /&gt;</span>),
</li><li> Otherwise it will generate a 404 (Not found) error (default).</li></ul></aside><aside class="concept" id="tyxml"><header><h5><span class="concept_prefix">Concept: </span>Static validation of HTML</h5></header><p>There are several ways to create pages for Eliom.  You can generate
pages as strings (as in other web frameworks). However, it is
preferable to generate HTML in a way that provides compile-time HTML
correctness guarantees. This tutorial achieves this by using the
module <span><a href=".././../../eliom/latest/api/Eliom_content.Html.D">Eliom_content.Html.D</a></span>,
which is implemented using the <span><a href=".././../../tyxml/latest/index">TyXML</a></span>
library.  The module defines a construction function for each HTML
tag.
</p><p><em>Note that it is also possible to use the usual HTML syntax directly
in OCaml, cf.  <span><a href=".././../../tyxml/latest/api/Pa_tyxml">Pa_tyxml</a></span>.</em>
</p><p>The TyXML library (and thus <span><a href=".././../../eliom/latest/api/Eliom_content.Html.D">Eliom_content.Html.D</a></span>) is very strict and compels you to respect
HTML standard (with some limitations). For example if you write:
</p><pre class=""><code class="language-ocaml translatable">(html
   (head (title (pcdata &quot;&quot;)) [pcdata &quot;&quot;])
   (body [pcdata &quot;Hallo&quot;]))</code></pre><p>You will get an error message similar to the following, referring to
the end of line 2:
</p><pre>Error: This expression has type ([&gt; `PCDATA ] as 'a) Html.elt
       but an expression was expected of type
         Html_types.head_content_fun Html.elt
       Type 'a is not compatible with type Html_types.head_content_fun =
           [ `Base
           | `Command
           | `Link
           | `Meta
           | `Noscript of [ `Link | `Meta | `Style ]
           | `Script
           | `Style ]
       The second variant type does not allow tag(s) `PCDATA
</pre><p>where <span><a href=".././../../tyxml/latest/api/Html_types#TYPEhead_content_fun">Html_types.head_content_fun</a></span>
is the type of content allowed inside <span class="teletype">&lt;head&gt;</span> (<span class="teletype">&lt;base&gt;</span>,
<span class="teletype">&lt;command&gt;</span>, <span class="teletype">&lt;link&gt;</span>, <span class="teletype">&lt;meta&gt;</span>, etc.). Notice that
<span class="teletype">`PCDATA</span> (i.e. raw text) is not included in this polymorphic
variant type, which means that <span class="teletype">&lt;head&gt;</span> cannot contain raw text.
</p><p>Most functions take as parameter the list representing its contents.
See other examples below. Each of them take an optional <span class="teletype">?a</span>
parameter for optional HTML attributes.
Mandatory HTML attributes correspond to mandatory OCaml parameters.
See below for examples.
</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Lwt</h5></header><p><strong>Important warning:</strong> All the functions you write must be written in
a cooperative manner using Lwt. Lwt is a convenient way to implement
concurrent programs in OCaml, and is now also widely used for
applications unrelated to Ocsigen.
</p><p>For now we will just use the <span class="teletype">Lwt.return</span> function as above.  We
will come back to Lwt programming later. You can also have a look at
the <span><a href=".././../../lwt/latest/index">Lwt programming guide</a></span>.</p></aside><h3>Execute parts of the program on the client</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Service sending an application<br/>
Client and server code<br/>
Compiling a web application with server and client parts<br/>
Calling JavaScript methods with Js_of_ocaml<br/></p></aside><p>To create our first service, we used the function <span><a href=".././../../eliom/latest/api/Eliom_registration.Html#VALcreate">Eliom_registration.Html.create</a></span>, as
all we wanted to do was return HTML. But we actually want a service
that corresponds to a full Eliom application with client and server
parts. To do so, we need to create our own registration module by
using the functor <span class="teletype">Eliom_registration.App</span>:
</p><pre class="server" class=""><code class="language-ocaml translatable">module Graffiti_app =
  Eliom_registration.App (struct
      let application_name = &quot;graffiti&quot;
      let global_data_path = None
    end)</code></pre><p>It is now possible to use <span class="teletype">Graffiti_app</span> for registering our main
service (now at URL <span class="teletype">/</span>):
</p><pre class="server" class=""><code class="language-ocaml translatable">let main_service =
  Graffiti_app.create
    ~path:(Eliom_service.Path [&quot;&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (pcdata &quot;Graffiti&quot;)) [])
           (body [h1 [pcdata &quot;Graffiti&quot;]]) ) )</code></pre><p>We can now add some OCaml code to be executed by the browser. For this
purpose, Eliom provides a syntax extension to distinguish between
server and client code in the same file. We start by a very basic
program, that will display a message to the user by calling the
JavaScript function <span class="teletype">alert</span>. Add the following lines to the
program:
</p><pre class="client" class=""><code class="language-ocaml translatable">let%client _ = Eliom_lib.alert &quot;Hello!&quot;</code></pre><p>After running again <span class="teletype">make test.byte</span>, and visiting
<a href="http://localhost:8080/" class="ocsimore_phrasing_link">http://localhost:8080/</a>, the browser will load the file
<span class="teletype">graffiti.js</span>, and open an alert-box.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Splitting the code into server and client parts</h5></header><p>At the very toplevel of your source file (i.e. <em>not</em> inside modules
or other server- /client-parts), you can use the following constructs
to indicate which side the code should run on.
</p><ul><li> <span class="teletype"> [%%client ... ] </span>: the list of enclosed definitions is
client-only code (similarly for <span class="teletype"> [%%server ... ] </span>). With
<span class="teletype"> [%%shared ... ] </span>, the code is used both on the server and client.
</li><li> <span class="teletype"> let%client </span>, <span class="teletype"> let%server </span>, <span class="teletype"> let%shared </span>: same as
above for a single definition.
</li><li> <span class="teletype"> [%%client.start] </span>, <span class="teletype"> [%%server.start] </span>,
<span class="teletype"> [%%shared.start] </span>: these set the default location for all
definitions that follow, and which do not use the preceding
constructs.
</li></ul><p>If no location is specified, the code is assumed to be for the server.
</p><p>The above constructs are implemented by means of PPX, OCaml's new
mechanism for implementing syntax extensions. See
<span><a href=".././../../eliom/latest/api/ppx/Ppx_eliom">Ppx_eliom</a></span> for details.
</p><p><strong>Client parts are executed once, when the client side process is
launched.</strong> The client process is not restarted after each page
change.
</p><p>In the Makefile created by the distillery, we automatically split the
code into client and server parts, compile the server part as usual,
and compile the client part to a JavaScript file using
<span class="teletype">js_of_ocaml</span>.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client values on the server</h5></header><p>Additionally, it is possible to create client values within the server
code by the following quotation:
</p><pre class=""><code class="language-ocaml translatable">[%client (expr : typ) ]</code></pre><p>where <span class="teletype">typ</span> is the type of an expression <span class="teletype">expr</span> on the client.
Note, that such a client value is abstract on the server, but becomes
concrete, once it is sent to the client with the next request.
</p><p>(The <span class="teletype">typ</span> can be ommitted if it can be inferred from the usage of
the client value in the server code.)
</p><p><strong>Client values are executed on the client after the service
returns.</strong> You can use client values when a service wants to ask the
client to run something, for example binding some event handler on
some element produced by the service.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Js_of_ocaml</h5></header><p>The client-side parts of the program are compiled to JavaScript by
<span class="teletype">js_of_ocaml</span>. (Technically, <span class="teletype">js_of_ocaml</span> compiles OCaml
bytecode to JavaScript.)  It is easy <span><a href=".././../../js_of_ocaml/latest/manual/bindings">to bind JavaScript libraries</a></span> so that OCaml
programs can call JavaScript functions. In the example, we are using
the <span><a href=".././../../js_of_ocaml/latest/api/Dom_html">Dom_html</a></span> module, which
is a binding that allows the manipulation of an HTML page.
</p><p>Js_of_ocaml is using a syntax extension to call JavaScript methods:
</p><ul><li> <span class="teletype">obj##m a b c</span> to call the method <span class="teletype">m</span> of object <span class="teletype">obj</span>
with parameters <span class="teletype">a</span>, <span class="teletype">b</span>, <span class="teletype">c</span>,
</li><li> <span class="teletype">obj##.m</span> to get a property,
</li><li> <span class="teletype">obj##.m := e</span> to set a property, and
</li><li> <span class="teletype">new%js constr a b c</span> to call a JavaScript constructor.
</li></ul><p>More information can be found in the Js_of_ocaml manual, in the module
<span><a href=".././../../js_of_ocaml/latest/api/Ppx_js">Ppx_js</a></span>.</p></aside><h3>Accessing server side variables on client side code</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Executing client side code after loading a page<br/>
Sharing server side values<br/>
Converting an HTML value to a portion of page (a.k.a. Dom node)<br/>
Manipulating HTML node 'by reference'</p></aside><p>The client side process is not strictly separated from the server
side.  We can access some server variables from the client code. For
instance:
</p><pre class="server" class=""><code class="language-ocaml translatable">let count = ref 0

let main_service =
  Graffiti_app.create
    ~path:(Eliom_service.Path [&quot;&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt;
       let c = incr count; !count in
       ignore [%client
         (Dom_html.window##alert
            (Js.string
               (Printf.sprintf &quot;You came %i times to this page&quot; ~%c))
          : unit)
       ];
       Lwt.return
         (html
            (head (title (pcdata &quot;Graffiti&quot;)) [])
            (body [h1 [pcdata &quot;Graffiti&quot;]])))</code></pre><p>Here, we are increasing the reference <span class="teletype">count</span> each time the page
is accessed. When the page is loaded and the document is in-place, the
client program initializes the value inside <span class="teletype"> [%client ... ] </span>,
and thus triggers an alert window. More specifically, the variable
<span class="teletype">c</span>, in the scope of the client value on the server is made
available to the client value using the syntax extension <span class="teletype">~%c</span>. In
doing so, the server side value <span class="teletype">c</span> is displayed in a message box
on the client.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Injections: Using server side values in client code</h5></header><p>Client side code can reference copies of server side values using
the <span class="teletype">~%variable</span> syntax.  Values sent that way are weakly type
checked: the name of the client side type must match the server side
one. If you define a type and want it to be available on both sides,
declare it in <span class="teletype"> [%%shared ... ] </span>. The Eliom manual provides more
information on the <span><a href=".././../../eliom/latest/api/ppx/Ppx_eliom">Eliom's syntax extension</a></span> and
its <span><a href=".././../../eliom/latest/manual/workflow-compilation#compilation">compilation process</a></span>.
</p><p>Note that the value of an injection into a <span class="teletype"> [%%client ... ] </span>
section is sent only once when starting the application in the
browser, and <em>not</em> synced automatically later. In contrast, the
values of injections into client values which are created during a
request are sent alongside the next response.</p></aside><h2 id="graffiti"> Collaborative drawing application <a class="backref" href="#graffiti">&#182;</a></h2><h3>Drawing on a canvas</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Canvas</p></aside><p>We now want to draw something on the page using an HTML canvas. The
drawing primitive is defined in the client-side function called
<span class="teletype">draw</span> that just draws a line between two given points in a canvas.
</p><p>To start our collaborative drawing application, we define another
client-side function <span class="teletype"> init_client </span>, which just draws a single
line for now.
</p><p>Here is the (full) new version of the program:
</p><pre class="shared" class=""><code class="language-ocaml translatable">[%%shared
  (* Modules opened in the shared-section are available in client-
     and server-code *)
  open Eliom_content.Html.D
  open Lwt
]</code></pre><pre class="server" class=""><code class="language-ocaml translatable">module Graffiti_app =
  Eliom_registration.App (
    struct
      let application_name = &quot;graffiti&quot;
      let global_data_path = None
    end)</code></pre><pre class="shared" class=""><code class="language-ocaml translatable">let%shared width  = 700
let%shared height = 400</code></pre><pre class="client" class=""><code class="language-ocaml translatable">let%client draw ctx ((r, g, b), size, (x1, y1), (x2, y2)) =
  let color = CSS.Color.string_of_t (CSS.Color.rgb r g b) in
  ctx##.strokeStyle := (Js.string color);
  ctx##.lineWidth := float size;
  ctx##beginPath;
  ctx##(moveTo (float x1) (float y1));
  ctx##(lineTo (float x2) (float y2));
  ctx##stroke</code></pre><pre class="server" class=""><code class="language-ocaml translatable">let canvas_elt =
  canvas ~a:[a_width width; a_height height]
    [pcdata &quot;your browser doesn't support canvas&quot;]

let page () =
  html
     (head (title (pcdata &quot;Graffiti&quot;)) [])
     (body [h1 [pcdata &quot;Graffiti&quot;];
            canvas_elt])</code></pre><pre class="client" class=""><code class="language-ocaml translatable">let%client init_client () =
  let canvas = Eliom_content.Html.To_dom.of_canvas ~%canvas_elt in
  let ctx = canvas##(getContext (Dom_html._2d_)) in
  ctx##.lineCap := Js.string &quot;round&quot;;
  draw ctx ((0, 0, 0), 12, (10, 10), (200, 100))</code></pre><pre class="server" class=""><code class="language-ocaml translatable">let main_service =
  Graffiti_app.create
    ~path:(Eliom_service.Path [&quot;&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt;
       (* Cf. section &quot;Client side side-effects on the server&quot; *)
       let _ = [%client (init_client () : unit) ] in
       Lwt.return (page ()))</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>JavaScript datatypes in OCaml</h5></header><p>Here we use the function <span><a href=".././../../js_of_ocaml/latest/api/Js#VALstring">Js.string</a></span> from Js_of_ocaml's library to convert an OCaml string
into a JS string.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client side side-effect on the server</h5></header><p>What sounds a bit weird at first, is a very convenient practice for
processing request in a client-server application: If a client value
is created while processing a request, it will be evaluated on the
client once it receives the response and the document is created;
the corresponding side effects are then executed.
For example, the line
</p><pre class=""><code class="language-ocaml translatable">let _ = [%client (init_client () : unit) ] in
    ...</code></pre><p>creates a client value for the sole purpose of performing side
effects on the client.  The client value can also be named (as
opposed to ignored via <span class="teletype">_</span>), thus enabling server-side
manipulation of client-side values (see below).</p></aside><h3>Single user drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Lwt<br/>
Mouse events with Lwt</p></aside><p>We now want to catch mouse events to draw lines with the mouse like
with the <em>brush</em> tools of any classical drawing application. One
solution would be to mimic typical JavaScript code in OCaml; for
example by using the function <span><a href=".././../../js_of_ocaml/latest/api/Dom_events#VALlisten">Dom_events.listen</a></span> that is the Js_of_ocaml's equivalent of
<span class="teletype">addEventListener</span>. However, this solution is at least as verbose
as the JavaScript equivalent, hence not satisfactory. Js_of_ocaml's
library provides a much easier way to do that with the help of Lwt.
</p><p>Replace the <span class="teletype">init_client</span> of the previous example by the
following piece of code, then compile and draw!
</p><pre class="client" class=""><code class="language-ocaml translatable">let%client init_client () =

  let canvas = Eliom_content.Html.To_dom.of_canvas ~%canvas_elt in
  let ctx = canvas##(getContext (Dom_html._2d_)) in
  ctx##.lineCap := Js.string &quot;round&quot;;

  let x = ref 0 and y = ref 0 in

  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##.clientX - x0; y := ev##.clientY - y0
  in

  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    ((0, 0, 0), 5, (oldx, oldy), (!x, !y))
  in

  let line ev = draw ctx (compute_line ev); Lwt.return () in

  Lwt.async (fun () -&gt;
    let open Lwt_js_events in
    mousedowns canvas
      (fun ev _ -&gt;
         set_coord ev; line ev &gt;&gt;= fun () -&gt;
           Lwt.pick
             [mousemoves Dom_html.document (fun x _ -&gt; line x);
	      mouseup Dom_html.document &gt;&gt;= line]))</code></pre><p>We use two references <span class="teletype">x</span> and <span class="teletype">y</span> to record the last mouse
position.  The function <span class="teletype">set_coord</span> updates those references from
mouse event data.  The function <span class="teletype">compute_line</span> computes the
coordinates of a line from the initial (old) coordinates to the new
coordinates–the event data sent as a parameter.
</p><p>The last four lines of code implement the event-handling loop.  They
can be read as follows: for each <span class="teletype">mousedown</span> event on the canvas,
do <span class="teletype">set_coord</span>, then <span class="teletype">line</span> (this will draw a dot), then
behave as the <span class="teletype">first</span> of the two following lines that terminates:
</p><ul><li> For each mousemove event on the document, call <span class="teletype">line</span> (never
terminates)
</li><li> If there is a mouseup event on the document, call <span class="teletype">line</span>.
</li></ul><aside class="concept" id="lwt"><header><h5><span class="concept_prefix">Concept: </span>More on Lwt</h5></header><p>Functions in Eliom and Js_of_ocaml which do not implement just a
computation or direct side effect, but rather wait for user activity,
or file system access, or need a unforseeable amount of time to return
are defined <em>with Lwt</em>; instead of returning a value of type <span class="teletype">a</span>
they return an Lwt thread of type <span class="teletype">a Lwt.t</span>.
</p><p>The only way to use the result of such functions (ones that return
values in the <em>Lwt monad</em>), is to use <span class="teletype">Lwt.bind</span>.
</p><pre class=""><code class="language-ocaml translatable">Lwt.bind : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b Lwt.t</code></pre><p>It is convenient to define an infix operator like this:
</p><pre class=""><code class="language-ocaml translatable">let (&gt;&gt;=) = Lwt.bind</code></pre><p>Then the code
</p><pre class=""><code class="language-ocaml translatable">f () &gt;&gt;= fun x -&gt;</code></pre><p>is conceptually similar to
</p><pre class=""><code class="language-ocaml translatable">let x = f () in</code></pre><p>but only for functions returning a value in the Lwt monad.
</p><p>For more clarity, there is a syntax extension for Lwt, defining
<span class="teletype">let%lwt</span> to be used instead of <span class="teletype">let</span> for Lwt functions:
</p><pre class=""><code class="language-ocaml translatable">let%lwt x = f () in</code></pre><p><span class="teletype">Lwt.return</span> creates a terminated thread from a value: </p><pre class=""><code class="language-ocaml translatable">Lwt.return : 'a -&gt; 'a Lwt.t</code></pre><p>Use it when you must
return something in the Lwt monad (for example in a service handler,
or often after a <span class="teletype">Lwt.bind</span>).
</p><h5>Why Lwt?</h5><p>An Eliom application is a cooperative program, as the server must be
able to handle several requests at the same time.  Ocsigen is using
cooperative threading instead of the more widely used preemptive
threading paradigm. It means that no scheduler will interrupt your
functions whenever it wants. Switching from one thread to another is
done only when there is a <em>cooperation point</em>.
</p><p>We will use the term <em>cooperative functions</em> to identify functions
implemented in cooperative way, that is: if something takes
(potentially a long) time to complete (for example reading a value
from a database), they insert a cooperation point to let other threads
run.  Cooperative functions return a value in the Lwt monad
(that is, a value of type <span class="teletype">'a Lwt.t</span> for some type <span class="teletype">'a</span>).
</p><p><span class="teletype">Lwt.bind</span> and <span class="teletype">Lwt.return</span> do not introduce cooperation points.
</p><p>In our example, the function <span class="teletype">Lwt_js_events.mouseup</span> may introduce
a cooperation point, because it is unforseeable when this event
happens. That's why it returns a value in the Lwt monad.
</p><p>Using cooperative threads has a huge advantage: given that you know
precisely where the cooperation points are, <em>you need very few
mutexes</em> and you have <em>very low risk of deadlocks</em>!
</p><p>Using Lwt is very easy and does not cause trouble, provided you never
use <em>blocking functions</em> (non-cooperative functions).  <em>Blocking
functions can cause the entre server to hang!</em> Remember:
</p><ul><li> Use the functions from module <span class="teletype">Lwt_unix</span> instead of module
<span class="teletype">Unix</span>,
</li><li> Use cooperative database libraries (like PG'Ocaml for Lwt),
</li><li> If you want to use a non-cooperative function, detach it in another
preemptive thread using <span><a href=".././../../lwt/latest/api/Lwt_preemptive#VALdetach">Lwt_preemptive.detach</a></span>,
</li><li> If you want to launch a long-running computation, manually insert
cooperation points using <span class="teletype">Lwt_unix.yield</span>,
</li><li> <span class="teletype">Lwt.bind</span> does not introduce any cooperation point.</li></ul></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Handling events with Lwt</h5></header><p>The module <span><a href=".././../../js_of_ocaml/latest/api/Lwt_js_events">Lwt_js_events</a></span>
allows easily defining event listeners using Lwt.  For example,
<span><a href=".././../../js_of_ocaml/latest/api/Lwt_js_events#VALclick">Lwt_js_events.click</a></span> takes a
DOM element and returns an Lwt thread that will wait until a click
occures on this element.
</p><p>Functions with an ending &quot;s&quot; (<span><a href=".././../../js_of_ocaml/latest/api/Lwt_js_events#VALclicks">Lwt_js_events.clicks</a></span>, <span><a href=".././../../js_of_ocaml/latest/api/Lwt_js_events#VALmousedowns">Lwt_js_events.mousedowns</a></span>, ...) start again waiting after the
handler terminates.
</p><p><span><a href=".././../../lwt/latest/api/Lwt#VALpick">Lwt.pick</a></span> behaves as the first thread
in the list to terminate, and cancels the others.</p></aside><h3>Collaborative drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Client server communication</p></aside><p>In order to see what other users are drawing, we now want to do the
following:
</p><ul><li> Send the coordinates to the server when the user draw a line, then
</li><li> Dispatch the coordinates to all connected users.
</li></ul><p>We first declare a type, shared by the server and the client,
describing the color (as RGB values) and coordinates of drawn lines.
</p><pre class="shared" class=""><code class="language-ocaml translatable">[%%shared
  type messages =
    ((int * int * int) * int * (int * int) * (int * int))
    [@@deriving json]
]</code></pre><p>We annotate the type declaration with <span class="teletype">[@@deriving json]</span> to allow
type-safe deserialization of this type. Eliom forces you to use this
in order to avoid server crashes if a client sends corrupted data.
This is defined using a JSON plugin for
<a href="https://github.com/whitequark/ppx_deriving" class="ocsimore_phrasing_link">ppx_deriving</a>, which you
need to install. You need to do that for each type of data sent by the
client to the server.  This annotation can only be added on types
containing exclusively basic types, or other types annotated with
<span class="teletype">[@@deriving json]</span>.
</p><p>Then we create an Eliom bus to broadcast drawing events to all client
with the function <span><a href=".././../../eliom/latest/api/server/Eliom_bus#VALcreate">Eliom_bus.create</a></span>. This function take as parameter the type of
values carried by the bus.
</p><pre class="server" class=""><code class="language-ocaml translatable">let bus = Eliom_bus.create [%derive.json: messages]</code></pre><p>To write draw commands into the bus, we just replace the function
<span class="teletype">line</span> in <span class="teletype">init_client</span> by:
</p><pre class="client" class=""><code class="language-ocaml translatable">let line ev =
  let v = compute_line ev in
  let _ = Eliom_bus.write ~%bus v in
  draw ctx v;
  Lwt.return () in</code></pre><p>Finally, to interpret the draw orders read on the bus, we add the
following line at the end of function <span class="teletype">init_client</span>:
</p><pre class="client" class=""><code class="language-ocaml translatable">Lwt.async (fun () -&gt; Lwt_stream.iter (draw ctx) (Eliom_bus.stream ~%bus))</code></pre><p>Now you can try the program using two browser windows to see that the
lines are drawn on both windows.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Communication channels</h5></header><p>Eliom provides multiple ways for the server to send unsolicited data
to the client:
</p><ul><li> <span><a href=".././../../eliom/latest/api/server/Eliom_bus#TYPEt">Eliom_bus.t</a></span> are broadcasting channels where
client and server can participate (see also <span><a href=".././../../eliom/latest/api/client/Eliom_bus#TYPEt">Eliom_bus.t</a></span> in the client
API).
</li><li> <span><a href=".././../../eliom/latest/api/server/Eliom_react">Eliom_react</a></span> allows sending
<a href="http://erratique.ch/software/react/doc/React" class="ocsimore_phrasing_link">React events</a> from
the server to the client, and conversely.
</li><li> <span><a href=".././../../eliom/latest/api/server/Eliom_comet.Channel#TYPEt">Eliom_comet.Channel.t</a></span> are one-way communication channels
allowing finer-grained control. It allows sending <span><a href=".././../../lwt/latest/api/Lwt_stream">Lwt_stream</a></span> to the client.
<span class="teletype">Eliom_react</span> and <span class="teletype">Eliom_bus</span> are implemented over
<span class="teletype">Eliom_comet</span>.
</li></ul><p>It is possible to control the idle behaviour with module <span><a href=".././../../eliom/latest/api/client/Eliom_comet.Configuration">Eliom_comet.Configuration</a></span>.</p></aside><h3>Color and size of the brush</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Widgets with Ocsigen-widgets</p></aside><p>In this section, we add a color picker and slider to choose the size
of the brush. For the colorpicker we used a widget available in
<span><a href=".././../../ocsigen-widgets/latest/manual/intro">Ocsigen-widgets</a></span>.
</p><p>To install Ocsigen widgets, do:
</p><pre>opam pin add ocsigen-widgets https://github.com/ocsigen/ocsigen-widgets.git
opam install ocsigen-widgets
</pre><p>In <span class="teletype">Makefile.options</span>, created by Eliom's distillery, add
<span class="teletype">ocsigen-widgets.client</span> to the
<span class="teletype">CLIENT_PACKAGES</span>:
</p><pre class="manually-translated"><code class="language-makefile">CLIENT_PACKAGES := ... ocsigen-widgets.client</code></pre><p>To create the widget, we add the following code in the
<span class="teletype">init_client</span> immediately after canvas configuration:
</p><pre class="client" class=""><code class="language-ocaml translatable">(* Color of the brush *)
let colorpicker = Ow_color_picker.create ~width:150 () in
Ow_color_picker.append_at (Dom_html.document##.body) colorpicker;
Ow_color_picker.init_handler colorpicker;</code></pre><p>We subsequently add a simple HTML slider to change the size of the
brush. Near the <span class="teletype">canvas_elt</span> definition, simply add the following
code:
</p><pre class="server" class=""><code class="language-ocaml translatable">let slider =
  Eliom_content.Html.D.Form.input
    ~a:[
      Html.D.a_id &quot;slider&quot;;
      Html.D.a_input_min (`Number 1);
      Html.D.a_input_max (`Number 80)
    ]
    ~input_type:`Range
    Html.D.Form.int</code></pre><p><span class="teletype">Form.int</span> is a typing information telling that this input takes
an integer value. This kind of input can only be associated to
services taking an integer as parameter.
</p><p>We then add the slider to the page body, as follows:
</p><pre class="server" class=""><code class="language-ocaml translatable">let page () =
  (html
    (head (title (pcdata &quot;Graffiti&quot;)) [])
    (body [h1 [pcdata &quot;Graffiti&quot;];
           canvas_elt;
           div [slider]] ))</code></pre><p>To change the size and the color of the brush, we replace the last
line of the function <span class="teletype">compute_line</span> in <span class="teletype">init_client</span> by:
</p><pre class="client" class=""><code class="language-ocaml translatable">let rgb = Ow_color_picker.get_rgb colorpicker in
let size_slider = Eliom_content.Html.To_dom.of_input ~%slider in
let size = int_of_string (Js.to_string size_slider##.value) in
(rgb, size, (oldx, oldy), (!x, !y))</code></pre><p>Finally, we need to add a stylesheet in the headers of our page. To
easily create the <span class="teletype">head</span> HTML element, we use the function <span><a href=".././../../eliom/latest/api/server/Eliom_tools.F#VALhead">Eliom_tools.F.head</a></span>:
</p><pre class="server" class=""><code class="language-ocaml translatable">let page () =
  html
    (Eliom_tools.F.head
       ~title:&quot;Graffiti&quot;
       ~css:[
         [&quot;css&quot;;&quot;graffiti.css&quot;];]
      ~js:[] ())
    (body [h1 [pcdata &quot;Graffiti&quot;]; canvas_elt; div [slider]])</code></pre><p>You need to install the corresponding stylesheets and images into your
project. The stylesheet files should go to the directory
<span class="teletype">static/css</span>.
File <span><a href=".././manual/files/tutorial/static/css/graffiti.css">{{{graffiti.css}}}</a></span> is a
custom-made CSS file.
</p><p>You can then test your application (<span class="teletype">make test.byte</span>).
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Ocsigen-widgets</h5></header><p>Ocsigen-widgets is a Js_of_ocaml library providing useful widgets
for your Eliom applications. You can use it for building complex
user interfaces. The full documentation is available
(<span><a href=".././../../ocsigen-widgets/latest/index">Ocsigen-widgets</a></span>).</p></aside><h3> Sending the initial image</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services sending other data types</p></aside><p>To finish the first part of the tutorial, we want to save the current
drawing on server side and send the current image when a new user
arrives. To do that, we will use the
<a href="https://github.com/Chris00/ocaml-cairo" class="ocsimore_phrasing_link">Cairo binding</a> for OCaml.
</p><p>For using Cairo, first, make sure that it is installed (it is
available as <span class="teletype">cairo2</span> via OPAM). Second, add it to the
<span class="teletype">SERVER_PACKAGES</span> in your <span class="teletype">Makefile.options</span>: </p><pre class="manually-translated"><code class="language-makefile">SERVER_PACKAGES := ... cairo2</code></pre><p>The <span class="teletype">draw_server</span> function below is the equivalent of the
<span class="teletype">draw</span> function on the server side and the <span class="teletype">image_string</span>
function outputs the PNG image in a string.
</p><pre class="server" class=""><code class="language-ocaml translatable">let draw_server, image_string =

  let surface = Cairo.Image.create Cairo.Image.ARGB32 ~width ~height in
  let ctx = Cairo.create surface in

  let rgb_floats_from_ints (r, g, b) =
    float r /. 255., float g /. 255., float b /. 255. in

  ((fun (rgb, size, (x1, y1), (x2, y2)) -&gt;

    (* Set thickness of brush *)
    Cairo.set_line_width ctx (float size) ;
    Cairo.set_line_join ctx Cairo.JOIN_ROUND ;
    Cairo.set_line_cap ctx Cairo.ROUND ;
    let r, g, b =  rgb_floats_from_ints rgb in
    Cairo.set_source_rgb ctx ~r ~g ~b ;

    Cairo.move_to ctx (float x1) (float y1) ;
    Cairo.line_to ctx (float x2) (float y2) ;
    Cairo.Path.close ctx ;

    (* Apply the ink *)
    Cairo.stroke ctx ;
   ),
   (fun () -&gt;
     let b = Buffer.create 10000 in
     (* Output a PNG in a string *)
     Cairo.PNG.write_to_stream surface (Buffer.add_string b);
     Buffer.contents b
   ))

let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus)</code></pre><p>We also define a service that sends the picture:
</p><pre class="server" class=""><code class="language-ocaml translatable">let imageservice =
  Eliom_registration.String.create
    ~path:(Eliom_service.Path [&quot;image&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt; Lwt.return (image_string (), &quot;image/png&quot;))</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Eliom_registration</h5></header><p>The module <span class="teletype">Eliom_registration</span> defines several modules with
registration and creation functions for a variety of data types.
We have already seen <span class="teletype">Eliom_registration.Html</span> and <span class="teletype">Eliom_registration.App</span>.
The module <span class="teletype">Eliom_registration.String</span> sends arbitrary byte output
(represented by an OCaml string). The handler function must return
a pair consisting of the content and the content-type.
</p><p>There are also several other output modules, for example:
</p><ul><li> <span class="teletype">Eliom_registration.File</span> to send static files
</li><li> <span class="teletype">Eliom_registration.Redirection</span> to create a redirection towards another page
</li><li> <span class="teletype">Eliom_registration.Any</span> to create services that decide late what
they want to send
</li><li> <span class="teletype">Eliom_registration.Ocaml</span> to send any OCaml data to be used in a
client side program
</li><li> <span class="teletype">Eliom_registration.Action</span> to create service with no output
(the handler function just performs a side effect on the server)
and reload the current page (or not). We will see an example of actions
in the next chapter.</li></ul></aside><p>We now want to load the initial image once the canvas is created.  Add
the following lines just between the creation of the canvas context and the
creation of the slider:
</p><pre class="server" class=""><code class="language-ocaml translatable">(* The initial image: *)
let img = Eliom_content.Html.To_dom.of_img
    (img ~alt:&quot;canvas&quot;
       ~src:(make_uri ~service:~%imageservice ())
       ())
in
img##.onload := Dom_html.handler (fun ev -&gt;
  ctx##drawImage img 0. 0.; Js._false);</code></pre><p>You are then ready to try your graffiti-application by
<span class="teletype">make test.byte</span>.
</p><p>Note, that the <span class="teletype">Makefile</span> from the distillery automatically adds
the packages defined in <span class="teletype">SERVER_PACKAGES</span> as an extension in your
configuration file <span class="teletype">local/etc/graffiti/graffiti-test.conf</span>:
</p><pre class="manually-translated"><code class="language-xml">&lt;extension findlib-package=&quot;cairo2&quot; /&gt;</code></pre><p>The first version of the program is now complete.
</p><div class="exercices"><h4>Exercises</h4><ul><li> Add a button that allows download the current
image, and saving it to the hard disk (reuse the service
<span class="teletype">imageservice</span>).
</li></ul><ul><li> Add a button with a color picker to select a color from the
drawing. Pressing the button changes the mouse cursor, and disables
current mouse events until the next mouse click event on the
document.  Then the color palette changes to the color of the pixel
clicked.  (Use the function <span class="teletype">Dom_html.pixel_get</span>).</li></ul></div><p><a href=".././manual/intro" class="ocsimore_phrasing_link">prev</a>
<a href=".././manual/interaction" class="ocsimore_phrasing_link">next</a></p></article></div></div></body></html>
