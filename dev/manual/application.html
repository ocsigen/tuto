<html><head><title>Writing a client/server Eliom application</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="https://ocsigen.org/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script type="application/javascript" src="https://ocsigen.org/js/client.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js">
//<![CDATA[

//]]>
</script></head><body class="application tuto"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href=".././../../" class="ocsimore_phrasing_link"><img src=".././../../img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><div class="mainmenu"><p class="mainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a></p><p class="mainmenu-current mainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a></p><p><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a></p><p><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a></p><p><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a></p><p><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a></p><p><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a></p><p><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a></p></div><form id="googlesearch" action="https://google.com/search"><input name="q" id="gsearch-box" placeholder="Search using Google"/><label for="gsearch-box"><img src="/img/search.svg" alt="" id="gsearch-icon"/></label><input type="submit" id="gsearch-submit" onclick="document.getElementById('gsearch-box').value += ' site:ocsigen.org';"/></form><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-toolkit/" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsipersist/" class="ocsimore_phrasing_link">Ocsipersist</a>
</li><li class="drawermainmenu-project"><a href=".././../../html_of_wiki/" class="ocsimore_phrasing_link">html_of_wiki</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsimore/" class="ocsimore_phrasing_link">Ocsimore (<em>deprecated</em>)</a>
</li><li class="drawermainmenu-page"><a href=".././../../projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href=".././../../papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href=".././../../credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href=".././../../contributing" class="ocsimore_phrasing_link">Contributing</a>
</li><li class="drawermainmenu-page"><a href=".././../../blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href=".././../../install" class="ocsimore_phrasing_link">Installation</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h1> Programmer's guide</h1><h2><a href="intro" class="ocsimore_phrasing_link">Introduction. Ocsigen: where to start?</a></h2><h2><a href="basics" class="ocsimore_phrasing_link">Client-server application programming guide</a></h2><h2><a href="basics-server" class="ocsimore_phrasing_link">Server-side website programming guide</a></h2><h1> Main tutorials</h1><h2><a href=".././../../install" class="ocsimore_phrasing_link">Install Ocsigen</a></h2><h2><a href="start" class="ocsimore_phrasing_link">Your first app in 5 minutes</a></h2><h2><a href="application" class="ocsimore_phrasing_link">Client/server application: Graffiti</a></h2><h2><a href="tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client-server widgets</a></h2><h2><a href="how-to-register-session-data" class="ocsimore_phrasing_link">Session data: Eliom references</a></h2><h2><a href="tutoreact" class="ocsimore_phrasing_link">Reactive client-server Web applications</a></h2><h2><a href="interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="misc" class="ocsimore_phrasing_link">Mixing traditional Web interaction with client-server app</a></h2><h1> 5-minute tutorials</h1><h2><a href="lwt" class="ocsimore_phrasing_link">Lwt</a></h2><h2><a href="html" class="ocsimore_phrasing_link">HTML</a></h2><h1> Other tutorials: Miscellanous features</h1><h2><a href="mobile" class="ocsimore_phrasing_link">Mobile applications with Ocsigen</a></h2><h2><a href="custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="rest" class="ocsimore_phrasing_link">RESTful JSON API</a></h2><h2><a href="ocsipersist" class="ocsimore_phrasing_link">Persistent tables with Ocsipersist</a></h2><h1> Improving Graffiti</h1><h2><a href="pictures" class="ocsimore_phrasing_link">Download pictures</a></h2><h2><a href="music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="reactivemediaplayer" class="ocsimore_phrasing_link">Reactive media player</a></h2><h1 class="howto"> HOW-TO</h1><h2> My first steps with Ocsigen</h2><h3><a href="how-to-make-hello-world-in-ocsigen" class="ocsimore_phrasing_link">How to make &quot;hello world&quot; in Ocsigen</a></h3><h3><a href="how-to-compile-my-ocsigen-pages" class="ocsimore_phrasing_link">How to compile my Ocsigen pages</a></h3><h3><a href="how-to-configure-and-launch-the-ocsigen-server" class="ocsimore_phrasing_link">How to configure and launch the Ocsigen Server</a></h3><h3><a href="how-does-a-page-s-source-code-look" class="ocsimore_phrasing_link">How does a client-server app source code look like?</a></h3><h2> How to put some elements in my page ?</h2><h3><a href="how-to-make-page-a-skeleton" class="ocsimore_phrasing_link">How to make a page skeleton</a></h3><h3><a href="how-to-use-get-parameters-or-parameters-in-the-url" class="ocsimore_phrasing_link">How to use GET parameters (parameters in the URL)</a></h3><h3><a href="how-to-add-css-stylesheet" class="ocsimore_phrasing_link">How to add CSS stylesheet</a></h3><h3><a href="how-to-add-a-javascript-script" class="ocsimore_phrasing_link">How to add a Javascript script</a></h3><h3><a href="how-to-add-a-div" class="ocsimore_phrasing_link">How to add a div</a></h3><h3><a href="how-to-add-a-list" class="ocsimore_phrasing_link">How to add lists in pages?</a></h3><h3><a href="how-to-add-an-image" class="ocsimore_phrasing_link">How to add an image</a></h3><h3><a href="how-to-write-titles-and-paragraphs" class="ocsimore_phrasing_link">How to write titles and paragraphs</a></h3><h3><a href="how-to-set-and-id-classes-or-other-attributes-to-html-elements" class="ocsimore_phrasing_link">How to set and id, classes or other attributes to HTML elements</a></h3><h3><a href="how-to-add-a-select-or-other-form-element" class="ocsimore_phrasing_link">How to add select (or other form element)</a></h3><h3><a href="how-to-insert-raw-form-elements-not-belonging-to-a-form-towards-a-service" class="ocsimore_phrasing_link">How to insert &quot;raw&quot; form elements (not belonging to a form towards a service)</a></h3><h3><a href="how-to-make-responsive-css" class="ocsimore_phrasing_link">How to make responsive CSS</a></h3><h2> Services</h2><h3><a href="how-to-do-links-to-other-pages" class="ocsimore_phrasing_link">How to do links to other pages</a></h3><h3><a href="how-to-write-forms" class="ocsimore_phrasing_link">How to write forms</a></h3><h3><a href="how-to-register-a-service-that-decides-itself-what-to-send" class="ocsimore_phrasing_link">How to register a service that decides itself what to send</a></h3><h3><a href="how-to-create-link-to-a-current-page-without-knowing-its-url" class="ocsimore_phrasing_link">How to create link to a current page (without knowing its URL)</a></h3><h3><a href="how-to-create-form-wizard-sequence-of-pages-depending-on-data-entered-on-previous-ones" class="ocsimore_phrasing_link">How to create form wizard (sequence of pages depending on data entered on previous ones)</a></h3><h3><a href="how-to-write-a-json-service" class="ocsimore_phrasing_link">How to write a JSON service</a></h3><h3><a href="how-to-send-file-download" class="ocsimore_phrasing_link">How to send a file (download)</a></h3><h3><a href="how-to-send-file-upload" class="ocsimore_phrasing_link">How to send a file (upload)</a></h3><h2> Js_of_ocaml</h2><h3><a href="how-to-attach-ocaml-values-to-dom-elements" class="ocsimore_phrasing_link">How to attach OCaml values to DOM elements</a></h3><h3><a href="how-to-know-whether-the-browser-window-has-the-focus-or-not" class="ocsimore_phrasing_link">How to know whether the browser window has the focus or not</a></h3><h3><a href="how-to-build-js-object" class="ocsimore_phrasing_link">How to build js object</a></h3><h3><a href="how-to-stop-default-behaviour-of-events" class="ocsimore_phrasing_link">How to stop default behaviour of events</a></h3><h3><a href="how-to-call-an-ocaml-function-from-js-code" class="ocsimore_phrasing_link">How to call an OCaml function from js code</a></h3><h2> Eliom client-server applications</h2><h3><a href="how-to-call-a-server-side-function-from-client-side" class="ocsimore_phrasing_link">How to call a server-side function from the client side</a></h3><h3><a href="how-to-make-the-client-side-program-get-an-html-element-from-the-server-and-insert-it-in-the-page" class="ocsimore_phrasing_link">How to make the client side program get an HTML element from the server and insert it in the page</a></h3><h3><a href="how-to-attach-ocaml-values-to-the-html-nodes-sent-to-the-client" class="ocsimore_phrasing_link">How to attach OCaml values to the HTML nodes sent to the client</a></h3><h3><a href="how-to-iterate-on-all-sessions-for-one-user-or-all-tabs" class="ocsimore_phrasing_link">How to iterate on all sessions for one user, or all tabs</a></h3><h3><a href="how-to-implement-a-notification-system" class="ocsimore_phrasing_link">How to implement a notification system</a></h3><h3><a href="how-to-send-a-file-to-server-without-stopping-the-client-process" class="ocsimore_phrasing_link">How to send a file to server without stopping the client process</a></h3><h3><a href="how-to-detect-channel-disconnection" class="ocsimore_phrasing_link">How to detect channel disconnection</a></h3><h3><a href="how-to-detect-on-client-side-that-the-server-side-state-for-the-process-is-closed" class="ocsimore_phrasing_link">How to detect on client side that the server side state for the process is closed</a></h3><h2> Eliom Server side</h2><h3><a href="how-do-i-create-a-cryptographically-safe-identifier" class="ocsimore_phrasing_link">How do I create a Cryptographically safe identifier</a></h3><h3><a href="hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h3></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol">Version <select class="how-versions" onchange="location = this.value;"><option value=".././../dev/manual/application" selected="selected">dev</option><option value=".././../8.0/manual/application">8.0</option><option value=".././../7.1/manual/application">7.1</option><option value=".././../2.2/manual/application">2.2</option></select><nav class="how-doctree"><h1> Programmer's guide</h1><h2><a href="intro" class="ocsimore_phrasing_link">Introduction. Ocsigen: where to start?</a></h2><h2><a href="basics" class="ocsimore_phrasing_link">Client-server application programming guide</a></h2><h2><a href="basics-server" class="ocsimore_phrasing_link">Server-side website programming guide</a></h2><h1> Main tutorials</h1><h2><a href=".././../../install" class="ocsimore_phrasing_link">Install Ocsigen</a></h2><h2><a href="start" class="ocsimore_phrasing_link">Your first app in 5 minutes</a></h2><h2><a href="application" class="ocsimore_phrasing_link">Client/server application: Graffiti</a></h2><h2><a href="tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client-server widgets</a></h2><h2><a href="how-to-register-session-data" class="ocsimore_phrasing_link">Session data: Eliom references</a></h2><h2><a href="tutoreact" class="ocsimore_phrasing_link">Reactive client-server Web applications</a></h2><h2><a href="interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="misc" class="ocsimore_phrasing_link">Mixing traditional Web interaction with client-server app</a></h2><h1> 5-minute tutorials</h1><h2><a href="lwt" class="ocsimore_phrasing_link">Lwt</a></h2><h2><a href="html" class="ocsimore_phrasing_link">HTML</a></h2><h1> Other tutorials: Miscellanous features</h1><h2><a href="mobile" class="ocsimore_phrasing_link">Mobile applications with Ocsigen</a></h2><h2><a href="custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="rest" class="ocsimore_phrasing_link">RESTful JSON API</a></h2><h2><a href="ocsipersist" class="ocsimore_phrasing_link">Persistent tables with Ocsipersist</a></h2><h1> Improving Graffiti</h1><h2><a href="pictures" class="ocsimore_phrasing_link">Download pictures</a></h2><h2><a href="music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="reactivemediaplayer" class="ocsimore_phrasing_link">Reactive media player</a></h2><h1 class="howto"> HOW-TO</h1><h2> My first steps with Ocsigen</h2><h3><a href="how-to-make-hello-world-in-ocsigen" class="ocsimore_phrasing_link">How to make &quot;hello world&quot; in Ocsigen</a></h3><h3><a href="how-to-compile-my-ocsigen-pages" class="ocsimore_phrasing_link">How to compile my Ocsigen pages</a></h3><h3><a href="how-to-configure-and-launch-the-ocsigen-server" class="ocsimore_phrasing_link">How to configure and launch the Ocsigen Server</a></h3><h3><a href="how-does-a-page-s-source-code-look" class="ocsimore_phrasing_link">How does a client-server app source code look like?</a></h3><h2> How to put some elements in my page ?</h2><h3><a href="how-to-make-page-a-skeleton" class="ocsimore_phrasing_link">How to make a page skeleton</a></h3><h3><a href="how-to-use-get-parameters-or-parameters-in-the-url" class="ocsimore_phrasing_link">How to use GET parameters (parameters in the URL)</a></h3><h3><a href="how-to-add-css-stylesheet" class="ocsimore_phrasing_link">How to add CSS stylesheet</a></h3><h3><a href="how-to-add-a-javascript-script" class="ocsimore_phrasing_link">How to add a Javascript script</a></h3><h3><a href="how-to-add-a-div" class="ocsimore_phrasing_link">How to add a div</a></h3><h3><a href="how-to-add-a-list" class="ocsimore_phrasing_link">How to add lists in pages?</a></h3><h3><a href="how-to-add-an-image" class="ocsimore_phrasing_link">How to add an image</a></h3><h3><a href="how-to-write-titles-and-paragraphs" class="ocsimore_phrasing_link">How to write titles and paragraphs</a></h3><h3><a href="how-to-set-and-id-classes-or-other-attributes-to-html-elements" class="ocsimore_phrasing_link">How to set and id, classes or other attributes to HTML elements</a></h3><h3><a href="how-to-add-a-select-or-other-form-element" class="ocsimore_phrasing_link">How to add select (or other form element)</a></h3><h3><a href="how-to-insert-raw-form-elements-not-belonging-to-a-form-towards-a-service" class="ocsimore_phrasing_link">How to insert &quot;raw&quot; form elements (not belonging to a form towards a service)</a></h3><h3><a href="how-to-make-responsive-css" class="ocsimore_phrasing_link">How to make responsive CSS</a></h3><h2> Services</h2><h3><a href="how-to-do-links-to-other-pages" class="ocsimore_phrasing_link">How to do links to other pages</a></h3><h3><a href="how-to-write-forms" class="ocsimore_phrasing_link">How to write forms</a></h3><h3><a href="how-to-register-a-service-that-decides-itself-what-to-send" class="ocsimore_phrasing_link">How to register a service that decides itself what to send</a></h3><h3><a href="how-to-create-link-to-a-current-page-without-knowing-its-url" class="ocsimore_phrasing_link">How to create link to a current page (without knowing its URL)</a></h3><h3><a href="how-to-create-form-wizard-sequence-of-pages-depending-on-data-entered-on-previous-ones" class="ocsimore_phrasing_link">How to create form wizard (sequence of pages depending on data entered on previous ones)</a></h3><h3><a href="how-to-write-a-json-service" class="ocsimore_phrasing_link">How to write a JSON service</a></h3><h3><a href="how-to-send-file-download" class="ocsimore_phrasing_link">How to send a file (download)</a></h3><h3><a href="how-to-send-file-upload" class="ocsimore_phrasing_link">How to send a file (upload)</a></h3><h2> Js_of_ocaml</h2><h3><a href="how-to-attach-ocaml-values-to-dom-elements" class="ocsimore_phrasing_link">How to attach OCaml values to DOM elements</a></h3><h3><a href="how-to-know-whether-the-browser-window-has-the-focus-or-not" class="ocsimore_phrasing_link">How to know whether the browser window has the focus or not</a></h3><h3><a href="how-to-build-js-object" class="ocsimore_phrasing_link">How to build js object</a></h3><h3><a href="how-to-stop-default-behaviour-of-events" class="ocsimore_phrasing_link">How to stop default behaviour of events</a></h3><h3><a href="how-to-call-an-ocaml-function-from-js-code" class="ocsimore_phrasing_link">How to call an OCaml function from js code</a></h3><h2> Eliom client-server applications</h2><h3><a href="how-to-call-a-server-side-function-from-client-side" class="ocsimore_phrasing_link">How to call a server-side function from the client side</a></h3><h3><a href="how-to-make-the-client-side-program-get-an-html-element-from-the-server-and-insert-it-in-the-page" class="ocsimore_phrasing_link">How to make the client side program get an HTML element from the server and insert it in the page</a></h3><h3><a href="how-to-attach-ocaml-values-to-the-html-nodes-sent-to-the-client" class="ocsimore_phrasing_link">How to attach OCaml values to the HTML nodes sent to the client</a></h3><h3><a href="how-to-iterate-on-all-sessions-for-one-user-or-all-tabs" class="ocsimore_phrasing_link">How to iterate on all sessions for one user, or all tabs</a></h3><h3><a href="how-to-implement-a-notification-system" class="ocsimore_phrasing_link">How to implement a notification system</a></h3><h3><a href="how-to-send-a-file-to-server-without-stopping-the-client-process" class="ocsimore_phrasing_link">How to send a file to server without stopping the client process</a></h3><h3><a href="how-to-detect-channel-disconnection" class="ocsimore_phrasing_link">How to detect channel disconnection</a></h3><h3><a href="how-to-detect-on-client-side-that-the-server-side-state-for-the-process-is-closed" class="ocsimore_phrasing_link">How to detect on client side that the server side state for the process is closed</a></h3><h2> Eliom Server side</h2><h3><a href="how-do-i-create-a-cryptographically-safe-identifier" class="ocsimore_phrasing_link">How do I create a Cryptographically safe identifier</a></h3><h3><a href="hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h3></nav></nav><article class="rightcol"><header><h1>Writing a client/server Eliom application</h1></header><p>In this chapter, we will write a <a href=".././../../graffiti/" class="ocsimore_phrasing_link">collaborative
drawing application</a>. It is a client/server web application
displaying an area where users can draw using the mouse, and see what
other users are drawing at the same time and in real-time.
</p><p>This tutorial is a good starting point if you want a step-by-step
introduction to Eliom programming.
</p>The final eliom code is available
<a href="https://github.com/ocsigen/graffiti/tree/master/simple" class="ocsimore_phrasing_link">for download</a>.<h2 id="basics"> Basics <a class="backref" href="#basics">&#182;</a></h2><p>If not already done, install Eliom first:
</p><pre>opam install ocsipersist-sqlite eliom ocsigen-ppx-rpc
</pre><p>To get started, we recommend using <span><a href=".././../../eliom/latest/manual/workflow-distillery">Eliom distillery</a></span>, a program which
creates scaffolds for Eliom projects. The following command creates a
very simple project called <span class="teletype">graffiti</span> in the directory
<span class="teletype">graffiti</span>:
</p><pre class="manually-translated"><code class="language-shell">$ eliom-distillery -name graffiti -template client-server.basic -target-directory graffiti</code></pre><h3>My first page</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services<br/>Configuration file<br/>Static validation of HTML</p></aside><p>Our web application consists of a single page for now. Let's start by
creating a very basic page. We define the service that will implement
this page by the following declaration:
</p><pre class="server" class=""><code class="language-ocaml translatable">open%server Eliom_content.Html.D (* provides functions to create HTML nodes *)

let%server main_service =
  Eliom_service.create
    ~path:(Eliom_service.Path [&quot;graff&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    ()

let%server () =
  Eliom_registration.Html.register ~service:main_service
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (txt &quot;Page title&quot;)) [])
           (body [h1 [txt &quot;Graffiti&quot;]])))</code></pre><p>Annotations <span class="teletype">%server</span> tells the compiler that the code is going to be executed
on the server (see later).
</p><p>Replace the content of file <span class="teletype">graffiti.eliom</span> by the above lines and run:
</p><pre class="manually-translated"><code class="language-shell">$ make test.byte</code></pre><p>This will compile your application and run <span class="teletype">ocsigenserver</span>.
</p><p>Your page is now available at URL <a href="http://localhost:8080/graff" class="ocsimore_phrasing_link"><span class="teletype">http://localhost:8080/graff</span></a>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Services</h5></header><p>Unlike typical web programming techniques (CGI, PHP, ...), with Eliom
you do not need to write one file per URL. The application can be
split into multiple files as per the developer's style. What matters
is that you eventually produce a single module (*.cmo or *.cma) for
the whole website.
</p><p>The module <span><a href=".././../../eliom/latest/api/server/Eliom_service">Eliom_service</a></span> allows to
create new entry points to your web site, called <em>services</em>. In
general, services are attached to a URL and generate a web page.
Services are represented by OCaml values, through which you must
register a function that will generate a page.
</p><p>The <span class="teletype">~path</span> parameter corresponds to the URL where you want to
attach your service. It is a list of strings.  The value
<code>[&quot;foo&quot;; &quot;bar&quot;]</code> corresponds to the URL
<code>foo/bar</code>.  <code>[&quot;dir&quot;; &quot;&quot;]</code> corresponds to
the URL <code>dir/</code> (that is: the default page of the
directory <code>dir</code>).</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Configuration file</h5></header><p>In the directory of the project created by the Eliom-distillery, you
can find the file <span class="teletype">graffiti.conf.in</span>. This file is used in
conjunction with the variables in <span class="teletype">Makefile.options</span> to generate
the <span class="teletype">ocsigenserver</span> configuration file.
</p><p>Once you start up your application via <span class="teletype">make test.byte</span>, the
configuration file becomes available at
<span class="teletype">local/etc/graffiti/graffiti-test.conf</span>. It contains various
directives for Ocsigen server (port, log files, extensions to be
loaded, etc.), taken from <span class="teletype">Makefile.options</span>, and something like:
</p><pre>&lt;host&gt;
  &lt;static dir=&quot;static&quot; /&gt;
  &lt;eliommodule module=&quot;/path_to/graffiti.cma&quot; /&gt;
  &lt;eliom /&gt;
&lt;/host&gt;
</pre><p><span class="teletype">&lt;eliommodule ... /&gt;</span> asks the server to load Eliom module
<span class="teletype">graffiti.cma</span>, containing the Eliom application,
at startup and attach it to this host (and site).
</p><p>Extensions <span class="teletype">&lt;static ... /&gt;</span> (staticmod) and <span class="teletype">&lt;eliom /&gt;</span>
are called successively:
</p><ul><li> If they exist, files from the directory <code>/path_to/graffiti/static</code> will be served,
</li><li> Otherwise, Server will try to generate pages with Eliom
(<span class="teletype">&lt;eliom /&gt;</span>),
</li><li> Otherwise it will generate a 404 (Not found) error (default).</li></ul></aside><aside class="concept" id="tyxml"><header><h5><span class="concept_prefix">Concept: </span>Static validation of HTML</h5></header><p>There are several ways to create pages for Eliom.  You can generate
pages as strings (as in other web frameworks). However, it is
preferable to generate HTML in a way that provides compile-time HTML
correctness guarantees. This tutorial achieves this by using the
module <span><a href=".././../../eliom/latest/api/server/Eliom_content.Html.D">Eliom_content.Html.D</a></span>,
which is implemented using the <span><a href=".././../../tyxml/index.html">TyXML</a></span>
library.  The module defines a construction function for each HTML
tag.
</p><p><em>Note that it is also possible to use the usual HTML syntax directly
in OCaml, cf.  <span><a href=".././../../tyxml/latest/api/Pa_tyxml">Pa_tyxml</a></span>.</em>
</p><p>The TyXML library (and thus <span><a href=".././../../eliom/latest/api/server/Eliom_content.Html.D">Eliom_content.Html.D</a></span>) is very strict and compels you to respect
HTML standard (with some limitations). For example if you write:
</p><pre class=""><code class="language-ocaml translatable">(html
   (head (title (txt &quot;&quot;)) [txt &quot;&quot;])
   (body [txt &quot;Hallo&quot;]))</code></pre><p>You will get an error message similar to the following, referring to
the end of line 2:
</p><pre>Error: This expression has type ([&gt; `TXT ] as 'a) Html.elt
       but an expression was expected of type
         Html_types.head_content_fun Html.elt
       Type 'a is not compatible with type Html_types.head_content_fun =
           [ `Base
           | `Command
           | `Link
           | `Meta
           | `Noscript of [ `Link | `Meta | `Style ]
           | `Script
           | `Style ]
       The second variant type does not allow tag(s) `TXT
</pre><p>where <span><a href=".././../../tyxml/latest/api/Html_types#TYPEhead_content_fun">Html_types.head_content_fun</a></span>
is the type of content allowed inside <span class="teletype">&lt;head&gt;</span> (<span class="teletype">&lt;base&gt;</span>,
<span class="teletype">&lt;command&gt;</span>, <span class="teletype">&lt;link&gt;</span>, <span class="teletype">&lt;meta&gt;</span>, etc.). Notice that
<span class="teletype">`TXT</span> (i.e. raw text) is not included in this polymorphic
variant type, which means that <span class="teletype">&lt;head&gt;</span> cannot contain raw text.
</p><p>Most functions take as parameter the list representing its contents.
See other examples below. Each of them take an optional <span class="teletype">?a</span>
parameter for optional HTML attributes.
Mandatory HTML attributes correspond to mandatory OCaml parameters.
See below for examples.
</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Lwt</h5></header><p><strong>Important warning:</strong> All the functions you write must be written in
a cooperative manner using Lwt. Lwt is a convenient way to implement
concurrent programs in OCaml, and is now also widely used for
applications unrelated to Ocsigen.
</p><p>For now we will just use the <span class="teletype">Lwt.return</span> function as above.  We
will come back to Lwt programming later. You can also have a look at
the <span><a href=".././../../lwt/index.html">Lwt programming guide</a></span>.</p></aside><h3>Execute parts of the program on the client</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Service sending an application<br/>
Client and server code<br/>
Compiling a Web application with server and client parts<br/>
Calling JavaScript methods with Js_of_ocaml<br/></p></aside><p>To create our first service, we used the function <span><a href=".././../../eliom/latest/api/server/Eliom_registration.Html#VALcreate">Eliom_registration.Html.create</a></span>, as
all we wanted to do was return HTML. But we actually want a service
that corresponds to a full application with client and server
parts. To do so, we need to create our own registration module by
using the functor <span class="teletype">Eliom_registration.App</span>:
</p><pre class="server" class=""><code class="language-ocaml translatable">module Graffiti_app =
  Eliom_registration.App (struct
      let application_name = &quot;graffiti&quot;
      let global_data_path = None
    end)</code></pre><p>It is now possible to use module <span class="teletype">Graffiti_app</span> for registering our main
service (now at URL <span class="teletype">/</span>):
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server main_service =
  Eliom_service.create
    ~path:(Eliom_service.Path [&quot;&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    ()

let%server () =
  Graffiti_app.register ~service:main_service
    (fun () () -&gt;
      Lwt.return
        (html
           (head (title (txt &quot;Graffiti&quot;)) [])
           (body [h1 [txt &quot;Graffiti&quot;]]) ) )</code></pre><p>We can now add some OCaml code to be executed by the browser. For this
purpose, Eliom provides a syntax extension to distinguish between
server and client code in the same file. We start by a very basic
program, that will display a message to the user by calling the
JavaScript function <span class="teletype">alert</span>. Add the following lines to the
program:
</p><pre class="client" class=""><code class="language-ocaml translatable">let%client _ = Eliom_lib.alert &quot;Hello!&quot;</code></pre><p>After running again <span class="teletype">make test.byte</span>, and visiting
<a href="http://localhost:8080/" class="ocsimore_phrasing_link">http://localhost:8080/</a>, the browser will load the file
<span class="teletype">graffiti.js</span>, and open an alert-box.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Splitting the code into server and client parts</h5></header><p>At the very toplevel of your source file (i.e. <em>not</em> inside modules
or other server- /client-parts), you can use the following constructs
to indicate which side the code should run on.
</p><ul><li> <span class="teletype"> let%client </span>, <span class="teletype"> let%server </span>, <span class="teletype"> let%shared </span>: same as
above for a single definition.
</li><li> other syntaxes like <span class="teletype"> module%server </span>, <span class="teletype"> open%client </span>,
<span class="teletype"> type%shared </span> ...
</li><li> <span class="teletype"> [%%client ... ] </span>: the list of enclosed definitions is
client-only code (similarly for <span class="teletype"> [%%server ... ] </span>). With
<span class="teletype"> [%%shared ... ] </span>, the code is used both on the server and client.
</li><li> <span class="teletype"> [%%client.start] </span>, <span class="teletype"> [%%server.start] </span>,
<span class="teletype"> [%%shared.start] </span>: these set the default location for all
definitions that follow, and which do not use the preceding
constructs.
</li></ul><p>If no location is specified, the code is assumed to be for the server.
</p><p>The above constructs are implemented by means of PPX, OCaml's new
mechanism for implementing syntax extensions. See
<span><a href=".././../../eliom/latest/api/ppx/Ppx_eliom">Ppx_eliom</a></span> for details.
</p><p><strong>Client parts are executed once, when the client side process is
launched.</strong> The client process is not restarted after each page
change.
</p><p>The Makefile created by <span class="teletype">eliom-distillery</span> automatically splits the
code into client and server parts, compiles the server part as usual,
and compile the client part to a JavaScript program using
<span class="teletype">js_of_ocaml</span>.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client values on the server</h5></header><p>Additionally, it is possible to create client values within the server
code by the following quotation:
</p><pre class="server" class=""><code class="language-ocaml translatable">[%client (expr : typ) ]</code></pre><p>where <span class="teletype">typ</span> is the type of an expression <span class="teletype">expr</span> on the client.
Note, that such a client value is abstract on the server, but becomes
concrete, once it is received by the client.
</p><p>(The <span class="teletype">typ</span> can be ommitted if it can be inferred from the usage of
the client value in the server code.)
</p><p><strong>Client values are executed on the client after the service
returns.</strong> You can use client values when a service wants to ask the
client to run something, for example binding some event handler on
some element produced by the service.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Js_of_ocaml</h5></header><p>The client-side parts of the program are compiled to JavaScript by
<span class="teletype">js_of_ocaml</span>. (Technically, <span class="teletype">js_of_ocaml</span> compiles OCaml
bytecode to JavaScript.)  It is easy <span><a href=".././../../js_of_ocaml/latest/manual/bindings">to bind JavaScript libraries</a></span> so that OCaml
programs can call JavaScript functions. In the example, we are using
the <span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml/Js_of_ocaml/Dom_html/#module-Dom_html">Js_of_ocaml.Dom_html</a></span> module, which
is a binding that allows the manipulation of an HTML page.
</p><p>Js_of_ocaml is using a syntax extension to call JavaScript methods:
</p><ul><li> <span class="teletype">obj##m a b c</span> to call the method <span class="teletype">m</span> of object <span class="teletype">obj</span>
with parameters <span class="teletype">a</span>, <span class="teletype">b</span>, <span class="teletype">c</span>,
</li><li> <span class="teletype">obj##.m</span> to get a property,
</li><li> <span class="teletype">obj##.m := e</span> to set a property, and
</li><li> <span class="teletype">new%js constr a b c</span> to call a JavaScript constructor.
</li></ul><p>More information can be found in the Js_of_ocaml manual, in module
<span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml-ppx/Ppx_js/#module-Ppx_js">Ppx_js</a></span>.</p></aside><h3>Accessing server side variables on client side code</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Executing client side code after loading a page<br/>
Sharing server side values<br/>
Converting an HTML value to a portion of page (a.k.a. Dom node)<br/>
Manipulating HTML node 'by reference'</p></aside><p>The client side process is not strictly separated from the server
side.  We can access some server variables from the client code. For
instance:
</p><pre class="client" class=""><code class="language-ocaml translatable">open%client Js_of_ocaml</code></pre><pre class="server" class=""><code class="language-ocaml translatable">let%server count = ref 0

let%server main_service =
  Eliom_service.create
    ~path:(Eliom_service.Path [&quot;&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    ()

let%server () =
  Graffiti_app.register ~service:main_service
    (fun () () -&gt;
       let c = incr count; !count in
       let text = Printf.sprintf &quot;You came %i times to this page&quot; in
       ignore [%client
         (Dom_html.window##alert
            (Js.string @@ Printf.sprintf &quot;You came %i times to this page&quot; ~%c)
          : unit)
       ];
       Lwt.return
         (html
            (head (title (txt &quot;Graffiti&quot;)) [])
            (body [h1 [txt @@ text c]])))</code></pre><p>Here, we are increasing the reference <span class="teletype">count</span> each time the page
is accessed. When the page is loaded and the document is in-place, the
client program initializes the value inside <span class="teletype"> [%client ... ] </span>,
and thus triggers an alert window. More specifically, the variable
<span class="teletype">c</span>, in the scope of the client value on the server is made
available to the client value using the syntax extension <span class="teletype">~%c</span>. In
doing so, the server side value <span class="teletype">c</span> is displayed in a message box
on the client.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Injections: Using server side values in client code</h5></header><p>Client side code can reference copies of server side values using
the <span class="teletype">~%variable</span> syntax.  Values sent that way are weakly type
checked: the name of the client side type must match the server side
one. If you define a type and want it to be available on both sides,
declare it in <span class="teletype"> [%%shared ... ]</span>. The Eliom manual provides more
information on the <span><a href=".././../../eliom/latest/api/ppx/Ppx_eliom">Eliom's syntax extension</a></span> and
its <span><a href=".././../../eliom/latest/manual/workflow-compilation#compilation">compilation process</a></span>.
</p><p>The value of an injection into a <span class="teletype"> let%client </span>
section is sent only once when starting the application in the
browser. In contrast, the
values of injections into client values which are created during a
request are sent alongside the next response.</p></aside><h2 id="graffiti"> Collaborative drawing application <a class="backref" href="#graffiti">&#182;</a></h2><h3>Drawing on a canvas</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Canvas</p></aside><p>We now want to draw something on the page using an HTML canvas. The
drawing primitive is defined in the client-side function called
<span class="teletype">draw</span> that just draws a line between two given points in a canvas.
</p><p>To start our collaborative drawing application, we define another
client-side function <span class="teletype"> init_client </span>, which just draws a single
line for now.
</p><p>Here is the (full) new version of the program:
</p><pre class="server" class=""><code class="language-ocaml translatable">open%server Eliom_content
open%server Eliom_content.Html.D</code></pre><pre class="client" class=""><code class="language-ocaml translatable">open%client Js_of_ocaml</code></pre><pre class="server" class=""><code class="language-ocaml translatable">module%server Graffiti_app =
  Eliom_registration.App (
    struct
      let application_name = &quot;graffiti&quot;
      let global_data_path = None
    end)</code></pre><pre class="server" class=""><code class="language-ocaml translatable">let%server width  = 700
let%server height = 400</code></pre><pre class="client" class=""><code class="language-ocaml translatable">let%client draw ctx ((r, g, b), size, (x1, y1), (x2, y2)) =
  let color = CSS.Color.string_of_t (CSS.Color.rgb r g b) in
  ctx##.strokeStyle := (Js.string color);
  ctx##.lineWidth := float size;
  ctx##beginPath;
  ctx##(moveTo (float x1) (float y1));
  ctx##(lineTo (float x2) (float y2));
  ctx##stroke</code></pre><pre class="server" class=""><code class="language-ocaml translatable">let%server canvas_elt =
  Html.D.canvas ~a:[Html.D.a_width width; Html.D.a_height height]
    [Html.D.txt &quot;your browser doesn't support canvas&quot;]

let%server page () =
  html
     (head (title (txt &quot;Graffiti&quot;)) [])
     (body [h1 [txt &quot;Graffiti&quot;];
            canvas_elt])</code></pre><pre class="client" class=""><code class="language-ocaml translatable">let%client init_client () =
  let canvas = Eliom_content.Html.To_dom.of_canvas ~%canvas_elt in
  let ctx = canvas##(getContext (Dom_html._2d_)) in
  ctx##.lineCap := Js.string &quot;round&quot;;
  draw ctx ((0, 0, 0), 12, (10, 10), (200, 100))</code></pre><pre class="server" class=""><code class="language-ocaml translatable">let%server main_service =
  Eliom_service.create
    ~path:(Eliom_service.Path [&quot;graff&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    ()

let%server () =
  Graffiti_app.register
    ~service:main_service
    (fun () () -&gt;
       (* Cf. section &quot;Client side side-effects on the server&quot; *)
       let _ = [%client (init_client () : unit) ] in
       Lwt.return (page ()))</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>JavaScript datatypes in OCaml</h5></header><p>Here we use the function <span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml/Js_of_ocaml/Js/#val-string">Js_of_ocaml.Js.string</a></span> from Js_of_ocaml's library to convert an OCaml string
into a JS string.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Client side side-effect on the server</h5></header><p>If a client value
is created while processing a request, it will be evaluated on the
client once it receives the response and the document is created;
the corresponding side effects are then executed.
For example, the line
</p><pre class=""><code class="language-ocaml translatable">let _ = [%client (init_client () : unit) ] in
    ...</code></pre><p>creates a client value for the sole purpose of performing side
effects on the client.  The client value can also be named (as
opposed to ignored via <span class="teletype">_</span>), thus enabling server-side
manipulation of client-side values (see below).</p></aside><h3>Single user drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Lwt<br/>
Mouse events with Lwt</p></aside><p>We now want to catch mouse events to draw lines with the mouse like
with the <em>brush</em> tools of any classical drawing application. One
solution would be to mimic typical JavaScript code in OCaml; for
example by using the function <span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml/Js_of_ocaml/Dom_events/#val-listen">Js_of_ocaml.Dom_events.listen</a></span> that is the Js_of_ocaml's equivalent of
<span class="teletype">addEventListener</span>. However, this solution is at least as verbose
as the JavaScript equivalent, hence not satisfactory. Js_of_ocaml's
library provides a much easier way to do that with the help of Lwt.
</p><p>To use this, add the following line on top of your file:
</p><pre class="client" class=""><code class="language-ocaml translatable">open%client Js_of_ocaml_lwt</code></pre><p>Then, replace the <span class="teletype">init_client</span> of the previous example by the
following piece of code, then compile and draw!
</p><pre class="client" class=""><code class="language-ocaml translatable">let%client init_client () =

  let canvas = Eliom_content.Html.To_dom.of_canvas ~%canvas_elt in
  let ctx = canvas##(getContext (Dom_html._2d_)) in
  ctx##.lineCap := Js.string &quot;round&quot;;

  let x = ref 0 and y = ref 0 in

  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##.clientX - x0; y := ev##.clientY - y0
  in

  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    ((0, 0, 0), 5, (oldx, oldy), (!x, !y))
  in

  let line ev = draw ctx (compute_line ev); Lwt.return () in

  Lwt.async (fun () -&gt;
    let open Lwt_js_events in
    mousedowns canvas
      (fun ev _ -&gt;
         set_coord ev;
         let%lwt () = line ev in
         Lwt.pick
           [mousemoves Dom_html.document (fun x _ -&gt; line x);
            let%lwt ev = mouseup Dom_html.document in line ev]))</code></pre><p>We use two references <span class="teletype">x</span> and <span class="teletype">y</span> to record the last mouse
position.  The function <span class="teletype">set_coord</span> updates those references from
mouse event data.  The function <span class="teletype">compute_line</span> computes the
coordinates of a line from the initial (old) coordinates to the new
coordinates–the event data sent as a parameter.
</p><p>The last four lines of code implement the event-handling loop.  They
can be read as follows: for each <span class="teletype">mousedown</span> event on the canvas,
do <span class="teletype">set_coord</span>, then <span class="teletype">line</span> (this will draw a dot), then
behave as the <span class="teletype">first</span> of the two following lines that terminates:
</p><ul><li> For each mousemove event on the document, call <span class="teletype">line</span> (never
terminates)
</li><li> If there is a mouseup event on the document, call <span class="teletype">line</span>.
</li></ul><aside class="concept" id="lwt"><header><h5><span class="concept_prefix">Concept: </span>More on Lwt</h5></header><p>Functions in Eliom and Js_of_ocaml which do not implement just a
computation or direct side effect, but rather wait for user activity,
or file system access, or need a unforseeable amount of time to return
are defined <em>with Lwt</em>; instead of returning a value of type <span class="teletype">a</span>
they return an Lwt thread of type <span class="teletype">a Lwt.t</span>.
</p><p>The only way to use the result of such functions (ones that return
values in the <em>Lwt monad</em>), is to use <span class="teletype">Lwt.bind</span>.
</p><pre class=""><code class="language-ocaml translatable">Lwt.bind : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b Lwt.t</code></pre><p>It is convenient to define an infix operator like this:
</p><pre class=""><code class="language-ocaml translatable">let (&gt;&gt;=) = Lwt.bind</code></pre><p>Then the code
</p><pre class=""><code class="language-ocaml translatable">f () &gt;&gt;= fun x -&gt;</code></pre><p>is conceptually similar to
</p><pre class=""><code class="language-ocaml translatable">let x = f () in</code></pre><p>but only for functions returning a value in the Lwt monad.
</p><p>For more clarity, there is a syntax extension for Lwt, defining
<span class="teletype">let%lwt</span> to be used instead of <span class="teletype">let</span> for Lwt functions:
</p><pre class=""><code class="language-ocaml translatable">let%lwt x = f () in</code></pre><p><span class="teletype">Lwt.return</span> creates a terminated thread from a value: </p><pre class=""><code class="language-ocaml translatable">Lwt.return : 'a -&gt; 'a Lwt.t</code></pre><p>Use it when you must
return something in the Lwt monad (for example in a service handler,
or often after a <span class="teletype">Lwt.bind</span>).
</p><h5>Why Lwt?</h5><p>An Eliom application is a cooperative program, as the server must be
able to handle several requests at the same time.  Ocsigen is using
cooperative threading instead of the more widely used preemptive
threading paradigm. It means that no scheduler will interrupt your
functions whenever it wants. Switching from one thread to another is
done only when there is a <em>cooperation point</em>.
</p><p>We will use the term <em>cooperative functions</em> to identify functions
implemented in cooperative way, that is: if something takes
(potentially a long) time to complete (for example reading a value
from a database), they insert a cooperation point to let other threads
run.  Cooperative functions return a value in the Lwt monad
(that is, a value of type <span class="teletype">'a Lwt.t</span> for some type <span class="teletype">'a</span>).
</p><p><span class="teletype">Lwt.bind</span> and <span class="teletype">Lwt.return</span> do not introduce cooperation points.
</p><p>In our example, the function <span class="teletype">Lwt_js_events.mouseup</span> may introduce
a cooperation point, because it is unforseeable when this event
happens. That's why it returns a value in the Lwt monad.
</p><p>Using cooperative threads has a huge advantage: given that you know
precisely where the cooperation points are, <em>you need very few
mutexes</em> and you have <em>very low risk of deadlocks</em>!
</p><p>Using Lwt is very easy and does not cause trouble, provided you never
use <em>blocking functions</em> (non-cooperative functions).  <em>Blocking
functions can cause the entre server to hang!</em> Remember:
</p><ul><li> Use the functions from module <span class="teletype">Lwt_unix</span> instead of module
<span class="teletype">Unix</span>,
</li><li> Use cooperative database libraries (like PG'Ocaml for Lwt),
</li><li> If you want to use a non-cooperative function, detach it in another
preemptive thread using <span><a href=".././../../lwt/latest/api/Lwt_preemptive#VALdetach">Lwt_preemptive.detach</a></span>,
</li><li> If you want to launch a long-running computation, manually insert
cooperation points using <span class="teletype">Lwt_unix.yield</span>,
</li><li> <span class="teletype">Lwt.bind</span> does not introduce any cooperation point.</li></ul></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Handling events with Lwt</h5></header><p>Module <span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml-lwt/Js_of_ocaml_lwt/Lwt_js_events/#module-Lwt_js_events">Js_of_ocaml_lwt.Lwt_js_events</a></span>
allows easily defining event listeners using Lwt.  For example,
<span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml-lwt/Js_of_ocaml_lwt/Lwt_js_events/#val-click">Js_of_ocaml_lwt.Lwt_js_events.click</a></span> takes a
DOM element and returns an Lwt thread that will wait until a click
occures on this element.
</p><p>Functions with an ending &quot;s&quot; (<span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml-lwt/Js_of_ocaml_lwt/Lwt_js_events/#val-clicks">Js_of_ocaml_lwt.Lwt_js_events.clicks</a></span>, <span><a href=".././../../js_of_ocaml/latest/api/js_of_ocaml-lwt/Js_of_ocaml_lwt/Lwt_js_events/#val-mousedowns">Js_of_ocaml_lwt.Lwt_js_events.mousedowns</a></span>, ...) start again waiting after the
handler terminates.
</p><p><span><a href=".././../../lwt/latest/api/Lwt#VALpick">Lwt.pick</a></span> behaves as the first thread
in the list to terminate, and cancels the others.</p></aside><h3>Collaborative drawing application</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Client server communication</p></aside><p>In order to see what other users are drawing, we now want to do the
following:
</p><ul><li> Send the coordinates to the server when the user draw a line, then
</li><li> Dispatch the coordinates to all connected users.
</li></ul><p>We first declare a type, shared by the server and the client,
describing the color (as RGB values) and coordinates of drawn lines.
</p><pre class="shared" class=""><code class="language-ocaml translatable">type%shared messages =
    ((int * int * int) * int * (int * int) * (int * int))
    [@@deriving json]</code></pre><p>We annotate the type declaration with <span class="teletype">[@@deriving json]</span> to allow
type-safe deserialization of this type. Eliom forces you to use this
in order to avoid server crashes if a client sends corrupted data.
This is defined using a JSON plugin for
<a href="https://github.com/whitequark/ppx_deriving" class="ocsimore_phrasing_link">ppx_deriving</a>, which you
need to install. You need to do that for each type of data sent by the
client to the server.  This annotation can only be added on types
containing exclusively basic types, or other types annotated with
<span class="teletype">[@@deriving json]</span>.
</p><p>Then we create an Eliom bus to broadcast drawing events to all client
with the function <span><a href=".././../../eliom/latest/api/server/Eliom_bus#VALcreate">Eliom_bus.create</a></span>. This function take as parameter the type of
values carried by the bus.
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server bus = Eliom_bus.create [%json: messages]</code></pre><p>To write draw commands into the bus, we just replace the function
<span class="teletype">line</span> in <span class="teletype">init_client</span> by:
</p><pre class="client" class=""><code class="language-ocaml translatable">let line ev =
  let v = compute_line ev in
  let _ = Eliom_bus.write ~%bus v in
  draw ctx v;
  Lwt.return ()
in</code></pre><p>Finally, to interpret the draw orders read on the bus, we add the
following line at the end of function <span class="teletype">init_client</span>:
</p><pre class="client" class=""><code class="language-ocaml translatable">Lwt.async (fun () -&gt;
    Lwt_stream.iter (draw ctx) (Eliom_bus.stream ~%(bus : (messages, messages) Eliom_bus.t)))</code></pre><p>Now you can try the program using two browser windows to see that the
lines are drawn on both windows.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Communication channels</h5></header><p>Eliom provides multiple ways for the server to send unsolicited data
to the client:
</p><ul><li> Module <span><a href=".././../../eliom/latest/api/server/Eliom_notif">Eliom_notif</a></span>
(or <span><a href=".././../../ocsigen-start/latest/api/server/Os_notif">Os_notif</a></span>
if you are using Ocsigen Start) provides a very simple way to send messages to
clients. It's probably the solution you will use most of the times.
</li><li> You can use <span><a href=".././../../eliom/latest/api/server/Eliom_bus#TYPEt">Eliom_bus.t</a></span> instead, as in this example, in the particular case
when you need to broadcast data to all connected clients. Buses are
broadcasting channels where
client and server can participate (see also <span><a href=".././../../eliom/latest/api/client/Eliom_bus#TYPEt">Eliom_bus.t</a></span> in the client
API).
</li><li> <span><a href=".././../../eliom/latest/api/server/Eliom_react">Eliom_react</a></span> allows sending
<a href="http://erratique.ch/software/react/doc/React" class="ocsimore_phrasing_link">React events</a> from
the server to the client, and conversely.
</li><li> <span><a href=".././../../eliom/latest/api/server/Eliom_comet.Channel#TYPEt">Eliom_comet.Channel.t</a></span> are one-way communication channels
allowing finer-grained control. It allows sending <span><a href=".././../../lwt/latest/api/Lwt_stream">Lwt_stream</a></span> to the client.
<span class="teletype">Eliom_react</span> and <span class="teletype">Eliom_bus</span> are implemented over
<span class="teletype">Eliom_comet</span>.
</li></ul><p>It is possible to control the idle behaviour with module <span><a href=".././../../eliom/latest/api/client/Eliom_comet.Configuration">Eliom_comet.Configuration</a></span>.</p></aside><h3>Color and size of the brush</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Widgets with Ocsigen Toolkit<br/>
Functional Reactive Programming<br/></p></aside><p>In this section, we add a color picker and slider to choose the size
of the brush. For the colorpicker we used a widget available in
<span><a href=".././../../ocsigen-toolkit/latest/manual/intro">Ocsigen Toolkit</a></span>.
</p><p>To install Ocsigen Toolkit, do:
</p><pre>opam install ocsigen-toolkit
</pre><p>Add package <span class="teletype">ocsigen-toolkit.server</span> to the <span class="teletype">libraries</span> section of your <span class="teletype">dune</span> file, and <span class="teletype">ocsigen-toolkit.client</span> to the <span class="teletype">libraries</span> section of your <span class="teletype">client/dune</span> file.
</p><pre>  (libraries ... ocsigen-toolkit.server)
</pre><pre>  (libraries ... ocsigen-toolkit.client)
</pre><p>In <span class="teletype">Makefile.options</span>, created by Eliom's distillery, add
<span class="teletype">ocsigen-toolkit.server</span> to the <span class="teletype">SERVER_PACKAGES</span>.
This will be used to regenerate Ocsigen Server's configuration file.
</p><pre class="manually-translated"><code class="language-makefile">SERVER_PACKAGES := ... ocsigen-toolkit.server</code></pre><p>To create the widget, we replace <span class="teletype">page</span> by :
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server page () =
  let colorpicker, cp_sig =
    Ot_color_picker.make ~a:[Html.D.a_class [&quot;colorpicker&quot;]] ()
  in
  ( Html.D.html
      (Html.D.head
         (Html.D.title (Html.D.txt &quot;Graffiti&quot;)) [])
      (Html.D.body [h1 [txt &quot;Graffiti&quot;]
                   ; canvas_elt
                   ; colorpicker])
  , cp_sig )</code></pre><p>Replace the registration of <span class="teletype">main_service</span> by:
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server () =
  Graffiti_app.register ~service:main_service
    (fun () () -&gt;
       (* Cf. section &quot;Client side side-effects on the server&quot; *)
      let page, cp_sig = page () in
       let _ = [%client (init_client ~cp_sig:~%cp_sig () : unit) ] in
       Lwt.return page)</code></pre><p>We subsequently add a simple HTML slider to change the size of the
brush. Near the <span class="teletype">canvas_elt</span> definition, simply add the following
code:
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server slider =
  Eliom_content.Html.D.Form.input
    ~a:
      [ Html.D.a_id &quot;slider&quot;
      ; Html.D.a_class [&quot;slider&quot;]
      ; Html.D.a_input_min (`Number 1)
      ; Html.D.a_input_max (`Number 80)
      ; Html.D.a_value &quot;22&quot; ]
    ~input_type:`Range Html.D.Form.int</code></pre><p><span class="teletype">Form.int</span> is a typing information telling that this input takes
an integer value. This kind of input can only be associated to
services taking an integer as parameter.
</p><p>We then add the slider to the page body, between the canvas and
the colorpicker.
</p><p>To change the size and the color of the brush, we add parameter
<span class="teletype">~cp_sig</span> to <span class="teletype">init_client</span> and modify
function <span class="teletype">compute_line</span>:
</p><pre class="client" class=""><code class="language-ocaml translatable">let%client init_client ~cp_sig () =
...
  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    let size_slider = Eliom_content.Html.To_dom.of_input ~%slider in
    let size = int_of_string (Js.to_string size_slider##.value) in
    let h, s, v = Eliom_shared.React.S.value cp_sig in
    let r, g, b = Ot_color_picker.hsv_to_rgb h s v in
    let rgb = int_of_float r, int_of_float g, int_of_float b in
    (rgb, size, (oldx, oldy), (!x, !y))
  in
...</code></pre><p>Finally, we need to add a stylesheet in the headers of our page
with function <span><a href=".././../../eliom/latest/api/server/Eliom_tools.D#VALcss_link">Eliom_tools.D.css_link</a></span>:
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server page () =
  let colorpicker, cp_sig =
    Ot_color_picker.make ~a:[Html.D.a_class [&quot;colorpicker&quot;]] ()
  in
  ( html
      (head
         (title (Html.D.txt &quot;Graffiti&quot;))
         [ css_link
             ~uri:
               (Html.D.make_uri
                  ~service:(Eliom_service.static_dir ())
                  [&quot;css&quot;; &quot;graffiti.css&quot;])
             ()
         ; css_link
             ~uri:
               (make_uri
                  ~service:(Eliom_service.static_dir ())
                  [&quot;css&quot;; &quot;ot_color_picker.css&quot;])
             () ])
      (body [canvas_elt; slider; colorpicker])
  , cp_sig )</code></pre><p>You need to install the corresponding stylesheets and images into your
project. The stylesheet files should go to the directory
<span class="teletype">static/css</span>.
Download file <span class="teletype">graffiti.css</span> from <span><a href=".././manual/files/tutorial/static/css/graffiti.css">here</a></span>.
Copy file <span class="teletype">ot_color_picker.css</span> from directory
<span class="teletype">~/.opam/&lt;version&gt;/share/ocsigen-toolkit/css</span> into <span class="teletype">static/css</span>.
</p><p>You can then test your application (<span class="teletype">make test.byte</span>).
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Ocsigen Toolkit</h5></header><p>Ocsigen Toolkit is a Js_of_ocaml library providing useful
client-server widgets
for your Eliom applications. You can use it for building complex
user interfaces. The full documentation is available
(<span><a href=".././../../ocsigen-toolkit/index.html">Ocsigen Toolkit</a></span>).</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Functional Reactive Programming</h5></header><p>Ocsigen Toolkit is using <em>Functional Reactive Programming</em> to
simplify and automatize page changes, through Daniel Bünzli's
React library.
</p><p>For example, <span class="teletype">Ot_color_picker.make</span> returns both the element
and a <em>reactive signal</em> on which you can bind other computations
or other page elements, that would be updated automatically when
the signal value changes.
</p><p>Eliom makes it possible to create reactive (client side) page elements
from server side, through module Eliom_shared.
</p><p>This basic program does not show the full power of reactive
programming, however. See <a href=".././manual/tutoreact" class="ocsimore_phrasing_link">this tutorial</a>
for a better introduction to reactive programming with Eliom.</p></aside><h3> Sending the initial image</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services sending other data types</p></aside><p>To finish the first part of the tutorial, we want to save the current
drawing on server side and send the current image when a new user
arrives. To do that, we will use the
<a href="https://github.com/Chris00/ocaml-cairo" class="ocsimore_phrasing_link">Cairo binding</a> for OCaml.
</p><p>For using Cairo, first, make sure that it is installed (it is
available as <span class="teletype">cairo2</span> via OPAM). Second, add it to the
<span class="teletype">libraries</span> section in your <span class="teletype">dune</span> file.
</p><p>Second, add it to the SERVER_PACKAGES in your Makefile.options:
</p><pre class="manually-translated"><code class="language-makefile">SERVER_PACKAGES := ... cairo2</code></pre><p>The <span class="teletype">draw_server</span> function below is the equivalent of the
<span class="teletype">draw</span> function on the server side and the <span class="teletype">image_string</span>
function outputs the PNG image in a string.
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server draw_server, image_string =
  let rgb_ints_to_floats (r, g, b) =
    float r /. 255., float g /. 255., float b /. 255.
  in
  (* needed by cairo *)
  let surface = Cairo.Image.create Cairo.Image.ARGB32 ~w:width ~h:height in
  let ctx = Cairo.create surface in
  ( (fun (rgb, size, (x1, y1), (x2, y2)) -&gt;
      (* Set thickness of brush *)
      let r, g, b = rgb_ints_to_floats rgb in
      Cairo.set_line_width ctx (float size);
      Cairo.set_line_join ctx Cairo.JOIN_ROUND;
      Cairo.set_line_cap ctx Cairo.ROUND;
      Cairo.set_source_rgb ctx r g b;
      Cairo.move_to ctx (float x1) (float y1);
      Cairo.line_to ctx (float x2) (float y2);
      Cairo.Path.close ctx;
      (* Apply the ink *)
      Cairo.stroke ctx)
  , fun () -&gt;
      let b = Buffer.create 10000 in
      (* Output a PNG in a string *)
      Cairo.PNG.write_to_stream surface (Buffer.add_string b);
      Buffer.contents b )

let%server _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus)</code></pre><p>We also define a service that sends the picture:
</p><pre class="server" class=""><code class="language-ocaml translatable">let%server imageservice =
  Eliom_service.create
    ~path:(Eliom_service.Path [&quot;image&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    ()

let%server () =
  Eliom_registration.String.register ~service:imageservice
    (fun () () -&gt; Lwt.return (image_string (), &quot;image/png&quot;))</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Eliom_registration</h5></header><p>The module <span class="teletype">Eliom_registration</span> defines several modules with
registration and creation functions for a variety of data types.
We have already seen <span class="teletype">Eliom_registration.Html</span> and <span class="teletype">Eliom_registration.App</span>.
The module <span class="teletype">Eliom_registration.String</span> sends arbitrary byte output
(represented by an OCaml string). The handler function must return
a pair consisting of the content and the content-type.
</p><p>There are also several other output modules, for example:
</p><ul><li> <span class="teletype">Eliom_registration.File</span> to send static files
</li><li> <span class="teletype">Eliom_registration.Redirection</span> to create a redirection towards another page
</li><li> <span class="teletype">Eliom_registration.Any</span> to create services that decide late what
they want to send
</li><li> <span class="teletype">Eliom_registration.Ocaml</span> to send any OCaml data to be used in a
client side program
</li><li> <span class="teletype">Eliom_registration.Action</span> to create service with no output
(the handler function just performs a side effect on the server)
and reload the current page (or not). We will see an example of actions
in the next chapter.</li></ul></aside><p>We now want to load the initial image once the canvas is created.  Add
the following lines just after the creation of the canvas context
in <span class="teletype">init_client</span>:
</p><pre class="server" class=""><code class="language-ocaml translatable">(* The initial image: *)
let img = Eliom_content.Html.To_dom.of_img
    (img ~alt:&quot;canvas&quot;
       ~src:(make_uri ~service:~%imageservice ())
       ())
in
img##.onload := Dom_html.handler (fun _ev -&gt;
  ctx##drawImage img 0. 0.; Js._false);</code></pre><p>As we are now using <span class="teletype">Eliom_content.Html.D</span> in both client and server sections,
we need to open it in a shared section:
</p><pre class="shared" class=""><code class="language-ocaml translatable">open%shared Eliom_content.Html.D</code></pre><p>Finally, we can add a new canvas where we would draw a visualisation of the
current size  of the brush. The complete code of this application
can be found <a href="https://github.com/ocsigen/graffiti/tree/master/simple" class="ocsimore_phrasing_link">here</a>.
</p><p>The <span class="teletype">Makefile</span> from the distillery automatically adds
the packages defined in <span class="teletype">SERVER_PACKAGES</span> as an extension in your
configuration file <span class="teletype">local/etc/graffiti/graffiti-test.conf</span>:
</p><pre class="manually-translated"><code class="language-xml">&lt;extension findlib-package=&quot;cairo2&quot; /&gt;</code></pre><p>The first version of the program is now complete.
</p><div class="exercices"><h4>Exercises</h4><ul><li> Add a button that allows download the current
image, and saving it to the hard disk (reuse the service
<span class="teletype">imageservice</span>).
</li></ul><ul><li> Add a button with a color picker to select a color from the
drawing. Pressing the button changes the mouse cursor, and disables
current mouse events until the next mouse click event on the
document.  Then the color palette changes to the color of the pixel
clicked.  (Use the function <span class="teletype">Dom_html.pixel_get</span>).</li></ul></div><p>If you want to continue learning client-server programming with Eliom
and build your first application, we suggest to read
<a href=".././manual/start" class="ocsimore_phrasing_link">the tutorial about Ocsigen Start</a>.</p></article></div></div></body></html>
