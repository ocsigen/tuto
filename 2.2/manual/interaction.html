<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Implementing Web Interaction Using Eliom</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="/home/balat/ocsigen/ocsigen.github.io/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js"></script><script src="/home/balat/ocsigen/html_of_wiki/client.js"></script></head><body class="tuto 2.2 interaction"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href="/" class="ocsimore_phrasing_link"><img src="/img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Doc
</p><ul class="mainmenu"><li class="mainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="mainmenu-doc mainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li></ul><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc drawermainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href="/ocsigenserver/2.9/manual/quickstart" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href="/ocsigen-toolkit/1.1.0/manual/intro" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-page"><a href="/projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href="/papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href="/credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href="/blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/2.2/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/2.2/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/2.2/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/2.2/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/2.2/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h2> More coming soon ...</h2></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol"><div class="how-versions"><input id="how-versions-toggle" type="checkbox"/><label for="how-versions-toggle" class="how-versions-current">Version 2.2</label><div class="how-versions-all"><a href="/tuto/dev/manual/interaction">dev</a><a href="/tuto/6.2/manual/interaction">6.2</a><a href="/tuto/6.1/manual/interaction">6.1</a><a href="/tuto/6.0/manual/interaction">6.0</a><a href="/tuto/5.0/manual/interaction">5.0</a><a href="/tuto/4.2/manual/interaction">4.2</a><a href="/tuto/4.1/manual/interaction">4.1</a><a href="/tuto/4.0/manual/interaction">4.0</a><a href="/tuto/3.0/manual/interaction">3.0</a><span class="how-versions-all-current">2.2</span><a href="/tuto/2.0/manual/interaction">2.0</a></div></div><form id="search"><input name="q" id="q" placeholder="search ..."/><button>Search</button></form><nav class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/2.2/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/2.2/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/2.2/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/2.2/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/2.2/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h2> More coming soon ...</h2></nav></nav><article class="rightcol"><h1>Implementing Web Interaction Using Eliom</h1><p><em>The code of this tutorial has been tested with the 2.2 release of
the Ocsigen bundle.</em><br/>
</p><p>This chapter is a tutorial explaining how to create a small Web site
with several pages, users, sessions, etc. Then, in next chapter,
we will incorporate the features of this site with the program from the
previous chapter, to show that we can
mix this kind of interaction with client-side programs.
</p><p>We assume you have read at least the first section of the previous
chapter, which explained how to create a service and constuct valid
HTML pages.
</p><p>We will create a simple Web site with one main page and a page for
each user (assuming we have several users already created).  Then we
will add a login/connection form. We will also add a registration
form, in order to learn how to create <em>dynamically</em> new services,
and why it is very useful.
</p><p>The <span><a href="/tuto/2.2/manual/files/tutorial.tar.gz" class="ocsforge_doclink_tuto">full code</a></span> of the program can be
downloaded.
</p><h2>Services</h2><h3>The main page</h3><p>Let's start again from scratch with the following site.
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content.Html5.D

let main_service =
  Eliom_registration.Html5.register_service
    ~path:[&quot;&quot;] ~get_params:Eliom_parameter.unit
    (fun () () -&gt;
      Lwt.return
        (html (head (title (pcdata &quot;&quot;)) [])
                       (body [h1 [pcdata &quot;Hello&quot;]])))</code></pre><p>Note that we are using <span class="teletype">Eliom_registration.Html5</span>, as we are not building a
client side program for now.
</p><p>Put this example in a file (<span class="teletype">tuto.ml</span>), compile it like so:
</p><pre>eliomc -c tuto.ml
</pre><p>Finally, modify your configuration file as explained in the previous
chapter to load the file <span class="teletype">tuto.cmo</span>. Then launch Ocsigen to run
the site.
</p><h3>Adding a page for each user</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services with parameters<br/>
Using parts of the path as parameters</p></aside><p>We will now create a page for each user. To do this, we will create a
new service, taking the user name as parameter:
</p><pre class=""><code class="language-ocaml translatable">let user_service =
  Eliom_registration.Html5.register_service
    ~path:[&quot;&quot;] ~get_params:(Eliom_parameter.string &quot;name&quot;)
    (fun name () -&gt;
      Lwt.return
        (html (head (title (pcdata name)) [])
                       (body [h1 [pcdata name]])))</code></pre><p>Add these lines to the same file, compile, start the server and verify
that everything is working by trying, for example:
<span class="teletype">http://localhost:8080/?name=toto</span>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Paths</h5></header><p>Note that we are using the same path as the first service.  Eliom will
automatically call the right service according to the parameters given
in the request.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Services with parameters</h5></header><p>To define a service that accepts parameters in the URL (GET
parameters), just add a description of the parameters you want in the
<span class="teletype">~get_params</span> argument of the <span class="teletype">register_service</span> function. In
our example, the service is expecting a parameter called <span class="teletype">name</span>,
of type <span class="teletype">string</span>.
</p><p>The handler function (function implementing the service) always takes
two parameters:
</p><ul><li> The first one corresponds to GET parameters (in our example, a string).
</li><li> The second one corresponds to parameters that are sent in the body
of the HTTP request (POST parameters). We will see soon how to make
services with POST parameters.
</li></ul><p>The module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_parameter">Eliom_parameter</a></span>
defines the possible parameter types. For example if you write:
</p><pre>~get_params:(Eliom_parameter.int &quot;i&quot;)
</pre><p>Eliom will try to find a parameter called <span class="teletype">i</span> and to translate it
into an <span class="teletype">int</span>.  In that case, the handler function will accept an
<span class="teletype">int</span> as the first parameter.
</p><p>If you want to accept several parameters, you can do, for example:
</p><pre>~get_params:(int &quot;i&quot; ** string &quot;s&quot;)
</pre><p>after opening the <span class="teletype">Eliom_parameter</span> module.  In that case, the
handler function takes a pair of type <span class="teletype">(int * string)</span>.
</p><p><em>Warning:</em> The operator <span class="teletype">**</span> is an infix <em>binary</em> operator.
It will always create pairs, and not triples or other tuples.
</p><p>The module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_parameter">Eliom_parameter</a></span> also
defines other parameter types: for example floats, 64 bits integers,
sum types, but also more complex types, like sets or lists of values.
It is also possible to define your own parameter types.</p></aside><p>For our program, we would prefer to take one part of the URL path as the parameter
describing the name of the user.
I change the definition of my service this way:
</p><pre class=""><code class="language-ocaml translatable">let user_service =
  Eliom_registration.Html5.register_service
    ~path:[&quot;users&quot;]
    ~get_params:
       (Eliom_parameter.suffix (Eliom_parameter.string &quot;name&quot;))
    (fun name () -&gt; ... )</code></pre><p>The user pages are now available at URLs <span class="code">http://localhost:8080/users/<em>username</em></span>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Using parts of the path as page parameters</h5></header><p>The module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_parameter">Eliom_parameter</a></span> makes
it possible to use parts of the path as service (GET) parameters.
</p><p>In addition to <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_parameter#VALsuffix">Eliom_parameter.​suffix</a></span>, there are many other values allowing you to specify your expected
parameters: for example, you may access the full suffix as a string,
as a list of string, or you may want to mix suffix parameters with
standard GET parameters. You can also accept, as parameters, parts of
the path that are not a suffix of the path (using <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_parameter#VALconst">Eliom_parameter.​const</a></span>).  See more information
on suffixes in <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/params#suffixes">Eliom's manual</a></span>.
</p><p><em>Warning:</em> Even if it is not displayed in the URL, suffix parameters
have a parameter name. This allows one to make forms that point to
those kind of services.  Actually each &quot;suffix service&quot; has an
equivalent without suffix (which is by default automatically
redirected towards the suffix version if it is a GET request).</p></aside><h3>Links</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Links <br/>
Database libraries</p></aside><p>We now want to add a link on each user page to go back to the main
page.
</p><p>Change the handler of <span class="teletype">user_service</span> into:
</p><pre class=""><code class="language-ocaml translatable">(fun name () -&gt; Lwt.return
  (html
    (head (title (pcdata name)) [])
    (body [h1 [pcdata name];
           p [a ~service:main_service [pcdata &quot;Home&quot;] ()]])))</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Creating hyperlinks</h5></header><p>To create a link, one could use the function <span class="teletype">Html5.a</span>, but this
requires us to provide the text of the URL to put in the <span class="teletype">href</span>
attribute. A better way to create hyperlinks is to use <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D#VALa">Eliom_content.​Html5.​D.​a</a></span>.
</p><p>Thus, you don't have to know the precise URL of the service you want
to link to, and if the URL changes, all links will remain valid.
Using this function has a wonderful consequence: <em>You will never have
broken links!</em>
</p><p>The function <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_content.Html5.D#VALa">Eliom_content.​Html5.​D.​a</a></span> accepts the following parameters:
</p><ul><li> the service
</li><li> the content of the link
</li><li> URL parameters to be given to the service</li></ul></aside><h4>Links towards services with parameters</h4><p>In our example above, the last parameter is <span class="teletype">()</span> because the
service does not expect any parameter. If the service expects, for
example, a pair <span class="teletype">(int * string)</span>, you must provide a matching
value as last parameter.  OCaml checks at compile time that the type
of the parameters in a link corresponds to the type expected by the
service! Also note that the parameter names are generated
automatically from the service, making it impossible to erroneously
create bad links.
</p><p>To show an example of a link with parameters, we will display the list
of user pages on the main page. Here is the new version of the full
program:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content.Html5.D
open Eliom_parameter

let main_service =
  Eliom_service.service ~path:[&quot;&quot;] ~get_params:unit ()

let user_service =
  Eliom_service.service
    ~path:[&quot;users&quot;] ~get_params:(suffix (string &quot;name&quot;)) ()

(* User names and passwords: *)
let users = ref [(&quot;Calvin&quot;, &quot;123&quot;); (&quot;Hobbes&quot;, &quot;456&quot;)]

let user_links () =
  ul (List.map (fun (name, _) -&gt; 
                  li [a
                        ~service:user_service [pcdata name] name])
               !users)

let _ =
  Eliom_registration.Html5.register
    ~service:main_service
    (fun () () -&gt;
      Lwt.return
        (html (head (title (pcdata &quot;&quot;)) [])
              (body [h1 [pcdata &quot;Hello&quot;];
                     user_links ()])));

  Eliom_registration.Html5.register
    ~service:user_service
    (fun name () -&gt;
      Lwt.return
        (html (head (title (pcdata name)) [])
              (body [h1 [pcdata name];
                     p [a ~service:main_service [pcdata &quot;Home&quot;] ()]])));</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Mutually recursive services</h5></header><p>As my two services are mutually recursive (the first one contains
links towards the second one and vice versa), we split the
<span class="teletype">register_service</span> in two steps:
</p><ul><li> First we create all the services using <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_service#VALservice">Eliom_service.​service</a></span>,
</li><li> Then we register the handlers using the <span class="teletype">register</span> function from
the right module.
</li></ul><p>The function <span class="teletype">register_service</span> is just a shortcut for these two functions.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Database libraries</h5></header><p>Ultimately we'll want to use a more sophisticated database module for
managing user information, which we will write later in this tutorial.
You can use any OCaml database binding (for example
<a href="http://developer.berlios.de/projects/pgocaml/" class="ocsimore_phrasing_link">PGOcaml</a> to program
database queries). We will use our own database library called
<a href="wiki(25):" class="ocsimore_phrasing_link">Macaque</a>, which implements typed requests using
<em>comprehensions</em>.
</p><p><em>Just remember that your query functions must be cooperative with
Lwt!</em> For example PGOcaml is now implemented in monadic way, which
makes it 100% compatible with Lwt. Macaque (the library we use later
in this tutorial) is as well.
</p><p>If your database module is not Lwt-cooperative but is thread-safe (for
preemptive threads), you can use the <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/api/Lwt_preemptive#VALdetach">Lwt_preemptive.​detach</a></span> function to make the blocking function be
executed by a separate preemptive thread.</p></aside><h2>Sessions</h2><h3>Connection service</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Services with hidden (POST) parameters<br/>
Fallback service</p></aside><p>Now I want to add a connection form.  First, I will create a service
for checking the name and password.  Since I don't want the username
and password to be shown in the URL, I will use <em>hidden parameters</em>
(or POST parameters).  Thus, I'll need to create a new service taking
these parameters:
</p><pre class=""><code class="language-ocaml translatable">let connection_service =
  Eliom_service.post_service
    ~fallback:main_service
    ~post_params:(string &quot;name&quot; ** string &quot;password&quot;)
    ()</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Hidden (POST) services</h5></header><p>Services using the POST HTTP method are created using the function
<span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_service#VALpost_service">Eliom_service.​post_service</a></span>.  As you can see, there is a major
difference from the function <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_service#VALservice">Eliom_service.​service</a></span>: <span class="teletype">post_service</span> does not take a path
as parameter, but a GET service as a <em>fallback</em>.
</p><p>This means that for each POST service, you must first create a GET
service at the same path that will answer if the user sets a bookmark
on the page and returns later without POST parameters.  In this way,
you will not get 404 errors if POST parameters are missing.
</p><p>If the fallback has GET parameters, your service will have both GET
and POST parameters. In that case, GET parameters will be in the URL
and POST parameters will probably come from a form. In HTML, it is not
possible to mix GET and POST parameters in the same form.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>POST or GET?</h5></header><p>POST parameters are sent in the body of the HTTP request (whereas GET
parameters are sent in the URL).  It is important to understand that
they have very different semantics.
</p><p>Remember:
</p><ul><li> Use GET parameters when you want your page to be bookmarkable.
</li><li> Use POST parameters when you do not want the page to be
bookmarkable, for example, because it performs a side effect on the
server (connecting a user, add something in a database, perform a
payment, etc.).
</li></ul><p><em>Warning:</em> Even if POST parameters are not shown in the URL, they
are sent in plain text. If you want to transmit private data (like a password),
you must
use HTTPS (see <span><a class="ocsforge_doclink_ocsigenserver" href="/ocsigenserver/2.9/manual/config">the Ocsigen server manual </a></span>).</p></aside><p>Now you can register a handler for the new service:
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Html5.register
    ~service:connection_service
    (fun () (name, password) -&gt;
      let message =
        if check_pwd name password
        then &quot;Hello &quot;^name
        else &quot;Wrong name or password&quot;
      in
      Lwt.return
        (html (head (title (pcdata &quot;&quot;)) [])
              (body [h1 [pcdata message];
                     user_links ()])));</code></pre><p>where <span class="teletype">check_pwd</span> is defined by:
</p><pre class=""><code class="language-ocaml translatable">let check_pwd name pwd =
  try List.assoc name !users = pwd with Not_found -&gt; false</code></pre><h3>Connection form</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Forms</p></aside><p>For now, I will add the connection form only on the main page of the
site.
</p><p>Let's create a function for generating the form:
</p><pre class=""><code class="language-ocaml translatable">let connection_box () =
  post_form ~service:connection_service
    (fun (name1, name2) -&gt;
      [fieldset
         [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
          string_input ~input_type:`Text
                                          ~name:name1 ();
          br ();
          label ~a:[a_for name2] [pcdata &quot;password: &quot;];
          string_input ~input_type:`Password
                                          ~name:name2 ();
          br ();
          string_input ~input_type:`Submit
                                          ~value:&quot;Connect&quot; ()
         ]]) ()</code></pre><p>Now, add a call to this function in the handler of the main service
(for example just before the user links).
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Forms</h5></header><p>Form creation is very similar to link creation, using the functions
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D#VALget_form">Eliom_content.​Html5.​D.​get_form</a></span> and <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D#VALpost_form">Eliom_content.​Html5.​D.​post_form</a></span>.
</p><p>The first parameter is the service, and the last parameter (only for
<span class="teletype">post_form</span>) is for GET parameters you want sent in the URL, if
the fallback of your POST service takes GET parameters.
</p><p>The only difference is how we write form content: instead of simply
giving the content as parameter to the <span class="teletype">get_form</span> or
<span class="teletype">post_form</span> functions, you supply a function that creates the form
from the names of the parameters the service is expecting.  Thus, you
don't need to remember the parameter names you chose while creating
the service, and you can change them easily without having to update
every form in your application.
</p><p>In the example, note that the service is expecting a pair 
<span class="teletype">(string * string)</span>.  The function given to <span class="teletype">post_form</span> takes two
parameters corresponding to the names of each field.
</p><p><span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.D">Eliom_content.​Html5.​D</a></span> (and
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.F">Eliom_content.​Html5.​F</a></span>)
defines constructors for all possible form fields.  OCaml checks that
the name you use matches the field.  For example it is not possible to
use the names above with <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_content.Html5.D#VALint_input">Eliom_content.​Html5.​D.​int_input</a></span> as it is a name for a string.</p></aside><h3>Opening a session</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Session data, Eliom references<br/>
Lwt</p></aside><p>Now we want to remember that the user is successfully connected.  To do
that we will set a reference when the user successfully connects, and
we will restrict the scope of this reference to the session (that is,
to the browser).
</p><p>Define your Eliom reference with a default value:
</p><pre class=""><code class="language-ocaml translatable">let username = Eliom_reference.eref ~scope:Eliom_common.session None</code></pre><p>Here is the new <span class="teletype">connection_box</span> function:
</p><pre class=""><code class="language-ocaml translatable">let connection_box () =
  lwt u = Eliom_reference.get username in
  Lwt.return
    (match u with
      | Some s -&gt; p [pcdata &quot;You are connected as &quot;; pcdata s]
      | None -&gt;
        post_form ~service:connection_service
          (fun (name1, name2) -&gt;
            [fieldset
	       [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
                string_input ~input_type:`Text
                                                ~name:name1 ();
                br ();
                label ~a:[a_for name2] [pcdata &quot;password: &quot;];
                string_input ~input_type:`Password
                                                ~name:name2 ();
                br ();
                string_input ~input_type:`Submit
                                                ~value:&quot;Connect&quot; ()
               ]]) ())</code></pre><p>... and replace the registration of the main service and the connection service by:
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Html5.register
    ~service:main_service
    (fun () () -&gt;
      lwt cf = connection_box () in
      Lwt.return
        (html (head (title (pcdata &quot;&quot;)) [])
              (body [h1 [pcdata &quot;Hello&quot;];
                     cf;
                     user_links ()])));

  Eliom_registration.Html5.register
    ~service:connection_service
    (fun () (name, password) -&gt;
      lwt message =
        if check_pwd name password
        then begin
          Eliom_reference.set username (Some name) &gt;&gt;=
            (fun _ -&gt; Lwt.return (&quot;Hello &quot;^name))
        end else
	  Lwt.return &quot;Wrong name or password&quot; in
      Lwt.return
        (html (head (title (pcdata &quot;&quot;)) [])
              (body [h1 [pcdata message];
                     user_links ()])));</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>More on Lwt</h5></header><p>Function <span class="teletype">Eliom_reference.get</span> has type
<span class="teletype">'a Eliom_reference.eref -&gt; 'a Lwt.t</span>.  The only way to use the result
of such functions (ones that return values in the <em>Lwt monad</em>), is
to use <span class="teletype">Lwt.bind</span>. 
</p><pre class=""><code class="language-ocaml translatable">Lwt.bind : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b
Lwt.t</code></pre><p>It is convenient to define an infix operator like this: </p><pre class=""><code class="language-ocaml translatable">let (&gt;&gt;=) = Lwt.bind</code></pre><p>Then the code </p><pre class=""><code class="language-ocaml translatable">f () &gt;&gt;= fun x -&gt;</code></pre><p>has to be read as </p><pre class=""><code class="language-ocaml translatable">let x = f () in</code></pre><p>but only for functions returning a
value in the Lwt monad.<br/>
</p><p>For more clarity, there is a syntax extension for Lwt, defining a
new keyword <span class="teletype">lwt</span> to be used instead of <span class="teletype">let</span> for Lwt
functions: </p><pre class=""><code class="language-ocaml translatable">lwt x = f () in</code></pre><p><span class="teletype">Lwt.return</span> creates a terminated thread from a value (without
inserting a cooperation point):
</p><pre class=""><code class="language-ocaml translatable">Lwt.return : 'a -&gt; 'a Lwt.t</code></pre><p>Use it when you must return something in the Lwt
monad (for example in a service handler, or often after a
<span class="teletype">Lwt.bind</span>).
</p><h5>Why Lwt?</h5><p>An Eliom application is a cooperative program, as the server must be
able to handle several requests at the same time.  Ocsigen is using
cooperative threading instead of the more widely used preemptive
threading paradigm. It means that no scheduler will interrupt your
functions whenever it wants. Switching from one thread to another is
done only when there is a <em>cooperation point</em>.
</p><p>We will use the term <em>cooperative functions</em> to identify functions
implemented in cooperative way, that is: if something takes
(potentially a long) time to complete (for example reading a value
from a database), they insert a cooperation point to let other threads
run.  Cooperative functions return a value in the Lwt monad
(that is, a value of type <span class="teletype">'a Lwt.t</span> for some type <span class="teletype">'a</span>).
</p><p>In our example, the function <span class="teletype">Eliom_state.get</span> may introduce a
cooperation point, because if your Eliom reference is persistent (see
below), it is stored in a database on the hard drive. That's why it
returns a value in the Lwt monad.
</p><p>Using cooperative threads has a huge advantage: as you know precisely
where cooperation points are, <em>you need very few mutexes</em> and you
have <em>very few risks of deadlocks</em>!
</p><p>Using Lwt is very easy and does not cause troubles, provided you never
use <em>blocking functions</em> (non cooperative functions).  <em>Blocking
functions can cause the entre server to hang!</em> Remember:
</p><ul><li> Use the functions from module <span class="teletype">Lwt_unix</span> instead of module
<span class="teletype">Unix</span>,
</li><li> Use cooperative database libraries (like PG'Ocaml for Lwt),
</li><li> If you want to use a non-cooperative function, detach it in another
preemptive thread using <span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/api/Lwt_preemptive#VALdetach">Lwt_preemptive.​detach</a></span>,
</li><li> If you want to launch a long-running computation, manually insert
cooperation points using <span class="teletype">Lwt_unix.yield</span>,
</li><li> <span class="teletype">Lwt.bind</span> does not introduce any cooperation point.</li></ul></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Eliom references and extended sessions</h5></header><p>Session data is stored in what we call <em>Eliom references</em>.
It is a type of reference whose value depend on the session the user
belongs to.
</p><p>Eliom is making the notion of session much more powerful by adding
other <em>scopes</em> for Eliom references. Instead of limiting the scope
to a session (that is: one browser), it is also possible to create
Eliom references with scope &quot;client-side process&quot;
(<span class="teletype">~scope:Eliom_common.client_process</span>), or &quot;group of sessions&quot; (see
later) (<span class="teletype">~scope:Eliom_common.session_group</span>), or &quot;current
request&quot; (<span class="teletype">~scope:Eliom_common.request</span>).
</p><p>Example: Say you want to implement a game, and make possible to have several instances of the game running in several tabs of the browser. Store the score on server side, as a &quot;client side process&quot; Eliom reference.
</p><p>Example: Grouping all the sessions for one user in a group of session makes possible to share a shopping basket between several devices (your mobile phone and your laptop for example).
</p><p>An Eliom reference is defined with the function
<span class="teletype">Eliom_reference.eref</span>, specifying the scope of this reference
and the default value. The function <span class="teletype">Eliom_reference.get</span>
retrieves the value of this reference for the current scope. 
The default value is used for
all sessions (or client process or group of sessions) for which it has not
been changed using <span class="teletype">Eliom_reference.set</span>.
</p><p>By default, Eliom references are kept in memory and will disappear if
you shut down the server. It is possible, however, to create
<em>persistent Eliom references</em> that will survive even a server
restart. To do that, add the optional parameter <span class="teletype">persistent</span> to
the <span class="teletype">eref</span> function, with a string value corresponding to the name
of the table that will contain the values on disk.
</p><aside class="wip"><header><h5>Work in progress</h5></header><p>For now you need to rename this table every time you change the type
of your Eliom reference, otherwise the server will crash (we are using
OCaml's <span class="teletype">Marshal</span> module).</p></aside><aside class="wip"><header><h5>Work in progress</h5></header><p>It is not possible to create Eliom references containing functions
(closures). We hope OCaml will include some mechanism to do that soon.</p></aside></aside><h3>Display the usual page after connection</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Actions</p></aside><p>As you can see, our connection service is displaying a welcome page
which is different from the main page in connected mode.  We would
rather display the same page.  One solution is to call the same
handler after registering session data.
</p><p>A cleaner solution is to use an <em>action</em>, that is: a service which will
just perform a side effect.  Replace the registration
of the connection service by:
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Action.register
    ~service:connection_service
    (fun () (name, password) -&gt;
      if check_pwd name password
      then Eliom_reference.set username (Some name)
      else Lwt.return ());</code></pre><p>Now the main page is displayed after connection.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Actions</h5></header><p>An <em>action</em> is a service that performs a side effect and redisplays
the current page. The handler function returns <span class="teletype">()</span>.</p></aside><h3>Putting a connection form on each page</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Non-attached coservices<br/>
Redirections</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Non-attached coservices</h5></header><p>With many Web programming frameworks, adding a connection form on each
page of a site is complicated, and is approached in one of two ways:
</p><ul><li> A first solution is similar to what we did for the main service, but
for all services (meaning that each page usually checks the presence
of POST parameters). This is clumsy.
</li><li> Another solution would be to create a special page on a separate
path to handle the registration, with some way to do a redirection
to the page we came from after connection. (Of course we want to
stay on the same page after sending the connection form!) This is
ugly.
</li></ul><p>With Eliom, this is more straightforward:
</p><ul><li> For the connection service, we use a kind of service called
<em>non-attached coservice</em>, which means that it is not attached to
any path in particular. Calling this kind of service will not change
the <em>path</em> you see in the browser URL bar (just add parameters if
you use the GET method).
</li><li> Use an action to connect the user and redisplay the page
corresponding to the current URL.
</li></ul><p>By default, a random identifier will be generated automatically by
Eliom for the non-attached coservice. If you want this identifier to
be fixed, you can specify it yourself while creating the service using
the <span class="teletype">?name</span> optional parameter. This identifier is added
automatically by Eliom in each form (as hidden field) and link.</p></aside><p>Transform the connection service into a non-attached coservice:
</p><pre class=""><code class="language-ocaml translatable">let connection_service =
  Eliom_service.post_coservice'
    ~post_params:(string &quot;name&quot; ** string &quot;password&quot;)
    ()</code></pre><p>Now you can add the connection box on user pages.
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Html5.register
    ~service:user_service
    (fun name () -&gt;
      connection_box () &gt;&gt;= fun cf -&gt;
      Lwt.return
        (html (head (title (pcdata name)) [])
              (body [h1 [pcdata name];
                     cf;
                     p [a
                          ~service:main_service [pcdata &quot;Home&quot;] ()]])));</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Altenative: register a redirection</h5></header><p>Usually, after sending a POST form, it is good practice to do a
redirection.  This avoids reposting the data if the user reloads the
page.
</p><p>Eliom provides the module <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_registration.Redirection">Eliom_registration.​Redirection</a></span> to register services doing
redirections.  Such services return a service without parameter.
</p><p>Example:
</p><pre class=""><code class="language-ocaml translatable">let redir_service = Eliom_registration.Redirection.register_service
    ~path:[&quot;redir&quot;]
    ~get_params:Eliom_parameter.unit
   (fun () () -&gt; Lwt.return main_service)</code></pre><p>(If you want to give parameters to the service you return, use <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_service#VALpreapply">Eliom_service.​preapply</a></span> —
more information in the <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/manual/services#p3preapplied">Eliom manual </a></span>.)
</p><p>If you want to do a redirection towards the current page (as in our
case), use the special service <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_service#VALvoid_coservice'">Eliom_service.​void_coservice'</a></span>, which is some kind of POST
non-attached coservice without parameter at all.</p></aside><h3>Disconnection</h3><p>To create a logout/disconnection form, we create another non-attached
coservice using POST method, and register another action.  We call the
function <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_state#VALdiscard">Eliom_state.​discard</a></span> with scope <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_common#VALsession">Eliom_common.​session</a></span> to remove all session
data.
</p><pre class=""><code class="language-ocaml translatable">let disconnection_service =
  Eliom_service.post_coservice' ~post_params:unit ()

let disconnect_box () =
  post_form disconnection_service
    (fun _ -&gt; [p [string_input
                    ~input_type:`Submit ~value:&quot;Log out&quot; ()]]) ()

let _ =
  Eliom_registration.Action.register
    ~service:disconnection_service
    (fun () () -&gt; Eliom_state.discard ~scope:Eliom_common.session ())</code></pre><p>Then add this form in the connection box:
</p><pre class=""><code class="language-ocaml translatable">let connection_box () =
  lwt u = Eliom_reference.get username in
  Lwt.return
    (match u with
      | Some s -&gt; div [p [pcdata &quot;You are connected as &quot;; pcdata s; ];
                       disconnect_box () ]
      | None -&gt; ...</code></pre><h2>Registration of users</h2><h3>Basic registration form</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Attached coservice</p></aside><p>We will now add a registration form to the application.  We create a
new regular service, attached to the path <span class="teletype">/registration</span>, that
displays a registration form, and an action that will add the user to
the &quot;database&quot;:
</p><pre class=""><code class="language-ocaml translatable">let new_user_form_service =
  Eliom_service.service ~path:[&quot;registration&quot;] ~get_params:unit ()

let create_account_service = 
  Eliom_service.post_coservice
    ~fallback:main_service
    ~post_params:(string &quot;name&quot; ** string &quot;password&quot;) ()

let create_account_form () =
  post_form ~service:create_account_service
    (fun (name1, name2) -&gt;
      [fieldset
         [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
          string_input ~input_type:`Text ~name:name1 ();
          br ();
          label ~a:[a_for name2] [pcdata &quot;password: &quot;];
          string_input ~input_type:`Password ~name:name2 ();
          br ();
          string_input ~input_type:`Submit ~value:&quot;Connect&quot; ()
         ]]) ()

let _ =
  Eliom_registration.Html5.register
    ~service:new_user_form_service
    (fun () () -&gt;
      Lwt.return
        (html (head (title (pcdata &quot;&quot;)) [])
              (body [h1 [pcdata &quot;Create an account&quot;];
                     create_account_form ();
                    ])));

  Eliom_registration.Action.register
    ~service:create_account_service
    (fun () (name, pwd) -&gt;
      users := (name, pwd)::!users;
      Lwt.return ())</code></pre><p>Then add the link to this service in the connection box:
</p><pre class=""><code class="language-ocaml translatable">let connection_box () =
  lwt u = Eliom_reference.get username in
  Lwt.return
    (match u with
      | Some s -&gt; div [p [pcdata &quot;You are connected as &quot;; pcdata s; ];
                       disconnect_box () ]
      | None -&gt;
        div [post_form ~service:connection_service
                (fun (name1, name2) -&gt;
...
                ) ();
             p [a new_user_form_service
                  [pcdata &quot;Create an account&quot;] ()]]
            )</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Attached coservice</h5></header><p>Here I want to return to the main page after account creation.  I'm
using an <em>attached coservice</em>, that is, a service that is identified
by both the path in the URL and a special coservice number (or name).
A form to such a service will change the path and send parameters
together with the coservice identifier (added automatically in an
hidden field).
</p><p>In this particular case, We could have used a regular service, as we
do not really need the coservice identifier, but in many cases, you
may want to distinguish between several services registered at the
same path (and with same parameters).  That's what attached coservices
are made for.</p></aside><h3>Registration form with confirmation</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Dynamic registration of services<br/>
Session services</p></aside><p>Now we want to add a confirmation page before actually creating the
account.  We <em>replace</em> the service <span class="teletype">create_account_service</span> by a
new POST attached coservice called <span class="teletype">account_confirmation_service</span>:
</p><pre class=""><code class="language-ocaml translatable">let account_confirmation_service =
  Eliom_service.post_coservice
    ~fallback:new_user_form_service
    ~post_params:(string &quot;name&quot; ** string &quot;password&quot;)
    ()</code></pre><p>and we make the account creation form point at this new service.
</p><p>We register an HTML handler on this service, with the confirmation
page.  As a side effect, this page will create the actual account
creation service:
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Html5.register
  ~service:account_confirmation_service
  (fun () (name, pwd) -&gt;
    let create_account_service =
      Eliom_registration.Action.register_coservice
        ~fallback:main_service
        ~get_params:Eliom_parameter.unit
        ~timeout:60.
        (fun () () -&gt;
          users := (name, pwd)::!users;
          Lwt.return ())
    in
    Lwt.return
      (html
        (head (title (pcdata &quot;&quot;)) [])
          (body
            [h1 [pcdata &quot;Confirm account creation for &quot;; pcdata name];
             p [a ~service:create_account_service [pcdata &quot;Yes&quot;] ();
                pcdata &quot; &quot;;
                a ~service:main_service [pcdata &quot;No&quot;] ()]
            ])));</code></pre><p>Also remove the registration of the <span class="teletype">create_account_service</span>
service and modify the user creation form to make it points towards
<span class="teletype">account_confirmation_service</span>.
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Dynamic creation of services</h5></header><p>In this example, we are dynamically creating a new service (here a
coservice that does an action).  This is done by the same
<span class="teletype">register</span> function as usual.
</p><p>Dynamic creation of new services allows one to create services that
depend on previous interaction with the user.  Here the
<span class="teletype">create_account_service</span> service depends on <span class="teletype">name</span> and
<span class="teletype">pwd</span>, that were previously sent by a form.
</p><p>In this simple example, an alternative would have been to send
<span class="teletype">name</span> and <span class="teletype">pwd</span> again to the same service as in the &quot;basic
registration form&quot; example. But this solution is not possible when you
have too much data.
</p><p><em>Saving <span class="teletype">name</span> and <span class="teletype">pwd</span> as session data is a wrong
solution!</em> If the user duplicates his browser window and fills out
the user creation form in both, then the confirmation link must create
the right account!
</p><p>A working alternative would have been to generate a random key, and
associate <span class="teletype">name</span> and <span class="teletype">pwd</span> with that key in a database table
on the server. This is the way such kind of Web interaction is usually
implemented. However, Eliom's solution is much simpler.
</p><p>The ability to register new services dynamically is implemented in few
Web frameworks, even though it simplifies a lot the programmating
involved with that type of Web interaction.  This feature is a variant
of what is called <em>continuation based Web programming</em>.  Think about
it when you want to <em>create a page that depends on previous
interaction with the user</em>. Dynamic registration of services will
automatically record the &quot;history&quot; of the interaction, and make
possible to use the &quot;back button&quot; or to have several tabs on the same
site.
</p><p>Examples of uses:
</p><ul><li> displaying the results of a search
</li><li> programming a &quot;several step form&quot; (when a form points at another
one, etc., like our registration form with confirmation).
</li></ul><p>On the other hand, if you want to implement a <em>shopping basket</em>, you
want it to be shared between all tabs of your Web site.  To do that,
you will use session data.
</p><p><em>Warning:</em> Services are kept in memory. To avoid memory leaks, you
probably want to put a timeout on your dynamic coservices. Just add
the optional parameter <span class="teletype">?timeout</span> to the service creation
function.</p></aside><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Session services</h5></header><p>Eliom also makes it possible to restrict the scope of services to a
session, a group of sessions, or even a client side process (if you
have a client side program running).  It works exactly like the scope
of Eliom references.  To do that, just add the optional parameter
<span class="teletype">~scope</span> to the registration function.  By default, the value is
<span class="teletype">Eliom_common.global</span> (visible for everyone).  Other possible
values: <span class="teletype">Eliom_common.session</span>, <span class="teletype">Eliom_common.session_group</span>,
or <span class="teletype">Eliom_common.client_process</span>.
</p><p>It is possible to register again for a session, tab or group, services
that have already been registered with public (site) visibility.  In
such cases, Eliom will try first tab services, then session services,
then group services, and finally site services.  This makes possible
to register specialized versions of a service for one user, for
example when she logs in.</p></aside><h2>A few enhancements</h2><h3>Displaying a &quot;wrong password&quot; message</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Scope &quot;request&quot;</p></aside><p>In the current version, our Web site fails silently when the password
is wrong.  Let's improve this behavior by displaying an error message.
To do that, we need to pass information to the service occurring after
the action. We record this information in an Eliom reference with
scope <span class="teletype">Eliom_common.request</span>.
</p><p>Define an Eliom reference:
</p><pre class=""><code class="language-ocaml translatable">let wrong_pwd = Eliom_reference.eref ~scope:Eliom_common.request false</code></pre><p>Modify the connection box this way:
</p><pre class=""><code class="language-ocaml translatable">let connection_box () =
  lwt u = Eliom_reference.get username in
  lwt wp = Eliom_reference.get wrong_pwd in
  Lwt.return
    (match u with
      | Some s -&gt; div [p [pcdata &quot;You are connected as &quot;; pcdata s; ];
                       disconnect_box () ]
      | None -&gt;
        let l =
          [post_form ~service:connection_service
            (fun (name1, name2) -&gt;
              [fieldset
	         [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
                  string_input ~input_type:`Text ~name:name1 ();
                  br ();
                  label ~a:[a_for name2] [pcdata &quot;password: &quot;];
                  string_input ~input_type:`Password ~name:name2 ();
                  br ();
                  string_input ~input_type:`Submit ~value:&quot;Connect&quot; ()
                 ]]) ();
             p [a new_user_form_service
                  [pcdata &quot;Create an account&quot;] ()]]
        in
        if wp
        then div ((p [em [pcdata &quot;Wrong user or password&quot;]])::l)
        else div l
    )</code></pre><p>... and modify the <span class="teletype">connection_service</span> handler:
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Action.register
    ~service:connection_service
    (fun () (name, password) -&gt;
      if check_pwd name password
      then Eliom_reference.set username (Some name)
      else Eliom_reference.set wrong_pwd true);</code></pre><h3>Sending 404 errors for non-existing users</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Sending 404<br/>
<span class="teletype">Eliom_registration.Any</span></p></aside><p>Our service <span class="teletype">user_service</span> responds to any request parameter, even
if the user does not exist in the database.  We want to check that the
user is in the database before displaying the page, and send a 404
error if the user is not.  To do that, we will replace the module
<span class="teletype"> My_app </span> by <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_registration.Any">Eliom_registration.​Any</a></span> to register the service <span class="teletype">user_service</span>:
</p><pre class=""><code class="language-ocaml translatable">Eliom_registration.Any.register
  ~service:user_service
  (fun name () -&gt;
    if List.exists (fun (n, _) -&gt; n = name) !users
    then begin
      lwt cf = connection_box () in
      Eliom_registration.Html5.send
        (html (head (title (pcdata name)) [])
              (body [h1 [pcdata name];
                     cf;
                     p [a ~service:main_service [pcdata &quot;Home&quot;] ()]]))
    end else
      Eliom_registration.Html5.send
        ~code:404
        (html (head (title (pcdata &quot;404&quot;)) [])
              (body [h1 [pcdata &quot;404&quot;];
                     p [pcdata &quot;That page does not exist&quot;]]))
    );</code></pre><p>&gt;
</p><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Eliom_registration.Any</h5></header><p>The module <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_registration.Any">Eliom_registration.​Any</a></span> can be used to create services that are
flexible to choose the kind of output they want to send.
</p><p>Use the <span class="teletype">send</span> function from the module you want to send the
output.  That function also allows, for example, to specify the HTTP
response code (here, we choose to use 404) or to set HTTP headers.</p></aside><aside class="wip"><header><h5>Work in progress</h5></header><p>In the future, we may add functions like <span class="teletype">set_http_code</span> or
<span class="teletype">set_http_header</span> to personalize the answer without using
<span class="teletype">Eliom_registration.Any</span>.</p></aside><h3>Using customized output module to simplify getting user data</h3><aside class="concepts"><header><h5>Concepts</h5></header><p><span class="teletype">Eliom_registration.Customize</span></p></aside><p>When you want to assume that you have informations available in
sessions, for instance when a site is mainly available to connected
users, it becomes tedious to check everywhere that a reference is not
None. We can build a version of a registration module to simplify that
using <span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/server/Eliom_registration.Customize">Eliom_registration.​Customize</a></span>.
</p><p>We first need a translation module which checks for session
informations and fall back to a default page if they are not
available.
</p><pre class=""><code class="language-ocaml translatable">module Connected_translate =
struct
  type page = string -&gt; Eliom_registration.Html5.page Lwt.t
  let translate page =
    lwt username = Eliom_reference.get username in
    match username with
    | None -&gt;
      let connection_box =
        post_form ~service:connection_service
          (fun (name1, name2) -&gt;
    	    [fieldset
	      [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
               string_input ~input_type:`Text ~name:name1 ();
               br ();
               label ~a:[a_for name2] [pcdata &quot;password: &quot;];
               string_input ~input_type:`Password ~name:name2 ();
               br ();
               string_input ~input_type:`Submit ~value:&quot;Connect&quot; ()
	     ]]) ()
      in
      Lwt.return
        (html 
	  (head (title (pcdata &quot;&quot;)) [])
          (body [h1 [pcdata &quot;Hello&quot;];
	         connection_box;]))
    | Some username -&gt; page username
end</code></pre><p>The <span class="teletype">translate</span> function takes a function <span class="teletype">page</span> and apply it
with the current username if available and falls back to a default
login page if not.
</p><p>We can now make our own registration module.
</p><pre class=""><code class="language-ocaml translatable">module Connected =
  Eliom_registration.Customize
    (Eliom_registration.Html5) (Connected_translate)

let _ = Connected.register_service 
  ~path:[&quot;&quot;] ~get_params:unit
  (fun () () -&gt;
    Lwt.return
     (fun username -&gt;
        Lwt.return (html (head (title (pcdata &quot;&quot;)) [])
                   (body [h1 [pcdata (&quot;Welcome &quot; ^ username) ]; ]))))</code></pre><p>The type of <span class="teletype">Connected.register_service</span> forces us to have the
heavy notation: <span class="teletype">Lwt.return (fun username -&gt; Lwt.return...)</span>. We
can make it lighter using
</p><pre class=""><code class="language-ocaml translatable">let ( !% ) f = fun a b -&gt;  Lwt.return (fun c -&gt; f a b c)

let _ = Connected.register_service 
  ~path:[&quot;&quot;] ~get_params:unit
  !% (fun () () username -&gt;
     Lwt.return (html (head  (title (pcdata &quot;&quot;)) [])
	      (body [h1 [pcdata (&quot;Welcome &quot; ^ username) ]; ])))</code></pre></article></div></div></body></html>
