<html><head><title>Miscellaneous features</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="https://ocsigen.org/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script type="application/javascript" src="https://ocsigen.org/js/client.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js">
//<![CDATA[

//]]>
</script></head><body class="misc tuto"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href=".././../../" class="ocsimore_phrasing_link"><img src=".././../../img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><div class="mainmenu"><p class="mainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a></p><p class="mainmenu-current mainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a></p><p><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a></p><p><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a></p><p><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a></p><p><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a></p><p><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a></p><p><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a></p></div><form id="googlesearch" action="https://google.com/search"><input name="q" id="gsearch-box" placeholder="Search using Google"/><label for="gsearch-box"><img src="/img/search.svg" alt="" id="gsearch-icon"/></label><input type="submit" id="gsearch-submit" onclick="document.getElementById('gsearch-box').value += ' site:ocsigen.org';"/></form><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-toolkit/" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsipersist/" class="ocsimore_phrasing_link">Ocsipersist</a>
</li><li class="drawermainmenu-project"><a href=".././../../html_of_wiki/" class="ocsimore_phrasing_link">html_of_wiki</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsimore/" class="ocsimore_phrasing_link">Ocsimore (<em>deprecated</em>)</a>
</li><li class="drawermainmenu-page"><a href=".././../../projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href=".././../../papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href=".././../../credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href=".././../../contributing" class="ocsimore_phrasing_link">Contributing</a>
</li><li class="drawermainmenu-page"><a href=".././../../blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href=".././../../install" class="ocsimore_phrasing_link">Installation</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="chat" class="ocsimore_phrasing_link">Chat</a></h2><h2> More coming soon ...</h2></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol">Version <select class="how-versions" onchange="location = this.value;"><option value=".././../dev/manual/misc">dev</option><option value=".././../8.0/manual/misc">8.0</option><option value=".././../7.1/manual/misc">7.1</option><option value=".././../2.2/manual/misc" selected="selected">2.2</option></select><nav class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="chat" class="ocsimore_phrasing_link">Chat</a></h2><h2> More coming soon ...</h2></nav></nav><article class="rightcol"><h1>Miscellaneous features</h1><p><em>The code of this tutorial has been tested with the 2.2 release of
the Ocsigen bundle.</em><br/>
</p><h2>Multi-user collaborative drawing application</h2><p>We now want to take back our collaborative drawing application and 
turn it to a multi user one. Each user will have his own drawing,
where everyone can draw, and the owner will have the ability to save
the drawing he wants and create an Atom feed containing all saved drawings.
</p><p>Download the <span><a href=".././manual/files/tutorial.tar.gz">full code</a></span> of the examples
or browse it
<a href="http://ocsigen.org/darcs/tutorial/files/tutorial/chapter3/multigraffiti" class="ocsimore_phrasing_link">online</a>.
</p><h3>Split application into multiple files and using several canvas</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Complex eliom project<br/>Unique elements</p></aside><p>In this first section, we will build a multi-canvas drawing application.
Each drawing has its own URL. Everyone can create a new drawing by going
to the corresponding URL.
</p><p>We need to refactor some parts. In particular, we need to be able to handle
separately different drawings. To do this, we will turn all global
variable, like the bus, in local ones.
</p><p>When an application grows, it start being useful to split it in
multiple files. For sake of example, we will split graffiti into 4
files.
</p><ul><li> <span class="teletype">common.ml</span> which will be part of both client and server,
containing shared types and declarations
</li><li> <span class="teletype">client.ml</span> client only part of the application
</li><li> <span class="teletype">server.ml</span> server only part of the application
</li><li> <span class="teletype">graffiti.eliom</span> the only part where we need to include both client and server code
</li></ul><h4><span class="teletype">common.ml</span></h4><p>It contains what was in <span class="teletype"> {shared{ .. }} </span>
</p><pre class=""><code class="language-ocaml translatable">type messages = (string * int * (int * int) * (int * int)) deriving (Json)

let width = 700
let height = 400</code></pre><h4><span class="teletype">client.ml</span></h4><p>It is almost the same code as what was enclosed in <span class="teletype"> {client{ ... }} </span>
with the difference that what was previously in
<span class="teletype"> Eliom_service.onload {{ }} </span> is now in the function <span class="teletype"> launch_client_canvas</span>.
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content
open Common
open Event_arrows

let draw ctx (color, size, (x1, y1), (x2, y2)) =
  ctx##strokeStyle &lt;- (Js.string color);
  ctx##lineWidth &lt;- float size;
  ctx##beginPath();
  ctx##moveTo(float x1, float y1);
  ctx##lineTo(float x2, float y2);
  ctx##stroke()

(* type containing all informations we need to stop interaction
   inside the page *)
type drawing_canceller =
    { drawing_thread : unit Lwt.t;
      (* the thread reading messages from the bus *)
      drawing_arrow : Event_arrows.canceller;
      (* the arrow handling mouse events *)
    }

let stop_drawing { drawing_thread; drawing_arrow } =
  Lwt.cancel drawing_thread;
  (* cancelling this thread also close the bus *)
  Event_arrows.cancel drawing_arrow</code></pre><p>Notice that the client does not keep data from pages it left.
<span class="teletype">Lwt.cancel t</span> stops the thread t. In this case it also closes the
bus on which t is listening. For more informations see the
<span><a href=".././../../lwt/index.html"> Lwt programming guide </a></span> and
<span><a href=".././../../eliom/dev/api/client/Eliom_bus">Eliom_bus</a></span>.
</p><pre class=""><code class="language-ocaml translatable">let launch_client_canvas bus image_elt canvas_elt =
  let canvas = Html5.To_dom.of_canvas canvas_elt in
  let ctx = canvas##getContext (Dom_html._2d_) in
  ctx##lineCap &lt;- Js.string &quot;round&quot;;

  let img = Html5.To_dom.of_img image_elt in
  let copy_image () = ctx##drawImage(img, 0., 0.) in
  if Js.to_bool (img##complete)
  then copy_image ()
  else img##onload &lt;- Dom_html.handler
    (fun ev -&gt; copy_image (); Js._false);

  (* Size of the brush *)
  let slider = jsnew Goog.Ui.slider(Js.null) in
  slider##setMinimum(1.);
  slider##setMaximum(80.);
  slider##setValue(10.);
  slider##setMoveToPointEnabled(Js._true);
  slider##render(Js.some Dom_html.document##body);

  (* The color palette: *)
  let pSmall =
    jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
                             Js.some (Js.string &quot;goog-hsv-palette-sm&quot;))
  in
  pSmall##render(Js.some Dom_html.document##body);

  let x = ref 0 and y = ref 0 in
  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##clientX - x0; y := ev##clientY - y0 in
  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    let color = Js.to_string (pSmall##getColor()) in
    let size = int_of_float (Js.to_float (slider##getValue())) in
    (color, size, (oldx, oldy), (!x, !y))
  in
  let line ev =
    let v = compute_line ev in
    let _ = Eliom_bus.write bus v in
    draw ctx v
  in
  let t = Lwt_stream.iter (draw ctx) (Eliom_bus.stream bus) in
  let drawing_arrow =
    run (mousedowns canvas
           (arr (fun ev -&gt; set_coord ev; line ev) &gt;&gt;&gt;
              first [mousemoves Dom_html.document (arr line);
                     mouseup Dom_html.document &gt;&gt;&gt; (arr line)])) () in
  { drawing_thread = t;
    drawing_arrow = drawing_arrow }</code></pre><h4><span class="teletype">server.ml</span></h4><p>It contains almost all the server parts of the code.
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content
open Eliom_content.Html5.D
open Common
open Lwt

module My_app =
  Eliom_registration.App (
    struct
      let application_name = &quot;graffiti&quot;
    end)

let rgb_from_string color = (* color is in format &quot;#rrggbb&quot; *)
  let get_color i =
    (float_of_string (&quot;0x&quot;^(String.sub color (1+2*i) 2))) /. 255.
  in
  try get_color 0, get_color 1, get_color 2 with | _ -&gt; 0.,0.,0.</code></pre><p>The main difference is that the bus is now local.
</p><pre class=""><code class="language-ocaml translatable">let launch_server_canvas () =
  let bus = Eliom_bus.create Json.t&lt;messages&gt; in

  let draw_server, image_string =
    let surface = Cairo.image_surface_create
      Cairo.FORMAT_ARGB32 ~width ~height in
    let ctx = Cairo.create surface in
    ((fun ((color : string), size, (x1, y1), (x2, y2)) -&gt;

      (* Set thickness of brush *)
      Cairo.set_line_width ctx (float size) ;
      Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
      Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
      let red, green, blue =  rgb_from_string color in
      Cairo.set_source_rgb ctx ~red ~green ~blue ;

      Cairo.move_to ctx (float x1) (float y1) ;
      Cairo.line_to ctx (float x2) (float y2) ;
      Cairo.close_path ctx ;

      (* Apply the ink *)
      Cairo.stroke ctx ;
     ),
     (fun () -&gt;
       let b = Buffer.create 10000 in
       (* Output a PNG in a string *)
       Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
       Buffer.contents b
     ))
  in
  let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus) in
  bus,image_string

let graffiti_info = Hashtbl.create 0

let imageservice =
  Eliom_registration.Text.register_service
    ~path:[&quot;image&quot;]
    ~headers:Http_headers.dyn_headers
    ~get_params:(let open Eliom_parameter in string &quot;name&quot; ** int &quot;q&quot;)
    (* we add an int parameter for the browser not to cache the image:
       at least for chrome, there is no way to force the browser to
       reload the image without leaving the application *)
    (fun (name,_) () -&gt;
      try_lwt
        let _ ,image_string = Hashtbl.find graffiti_info name in
	Lwt.return (image_string (), &quot;image/png&quot;)
      with
	| Not_found -&gt; raise_lwt Eliom_common.Eliom_404)

let get_bus (name:string) =
  (* create a new bus and image_string function only if it did not exists *)
  try
    fst (Hashtbl.find graffiti_info name)
  with
    | Not_found -&gt;
      let bus,image_string = launch_server_canvas () in
      Hashtbl.add graffiti_info name (bus,image_string);
      bus</code></pre><p>The main page now contains only a
form to choose to which drawing you want to go.
The drawing will be sent by the <span class="teletype">multigraffiti_service</span> service,
registered in <span class="teletype">graffiti.eliom</span>.
</p><pre class=""><code class="language-ocaml translatable">let main_service = Eliom_service.service ~path:[&quot;&quot;]
  ~get_params:(Eliom_parameter.unit) ()
let multigraffiti_service = Eliom_service.service ~path:[&quot;&quot;]
  ~get_params:(Eliom_parameter.suffix (Eliom_parameter.string &quot;name&quot;)) ()

let choose_drawing_form () =
  get_form ~service:multigraffiti_service
    (fun (name) -&gt;
      [fieldset
          [label ~a:[a_for name]
             [pcdata &quot;drawing name: &quot;];
           string_input ~input_type:`Text ~name ();
           br ();
           string_input ~input_type:`Submit ~value:&quot;Go&quot; ()
          ]])
    
let oclosure_script =
  Html5.Id.create_global_elt
    (js_script
       ~uri:(make_uri  (Eliom_service.static_dir ())
               [&quot;graffiti_oclosure.js&quot;]) ())

let make_page content =
  Lwt.return
    (html
       (head
	  (title (pcdata &quot;Graffiti&quot;))
       [ css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;common.css&quot;]) ();
         css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;hsvpalette.css&quot;]) ();
         css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;slider.css&quot;]) ();
         oclosure_script;
         css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;graffiti.css&quot;]) ();
       ])
       (body content))

let () = My_app.register ~service:main_service
  (fun () () -&gt;
    make_page [h1 [pcdata &quot;Welcome to Multigraffiti&quot;];
	       choose_drawing_form ()])</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Global node and scripts</h5></header><p>Sometimes we need to control when a script is loaded and reloaded on
page change. Since clicking on links in an Eliom application do not
reload the entire page, already loaded libraries stay loaded. But if
we simply add a script to each page, it will be loaded each time.
We usually don't want that.
</p><p>Using <span><a href=".././../../eliom/latest/api/Eliom_content.Html5.Id#VALcreate_global_elt">Eliom_content.Html5.Id.create_global_elt</a></span> we can create an xml node
manipulated 'by reference'. If a reference to a script node is
included in a page, it will only be loaded the first time it appears
in the header. Such a node can be created that way:
</p><pre class=""><code class="language-ocaml translatable">let oclosure_script =
  Eliom_content.Html5.Id.create_global_elt
    (js_script
       ~uri:(make_uri  (Eliom_service.static_dir ())
               [&quot;graffiti_oclosure.js&quot;]) ())</code></pre></aside><h4><span class="teletype">graffiti.eliom</span></h4><p>Here is the code that mixes client and server parts.
</p><p>We first open the corresponding modules for each parts of the
application.
</p><pre class=""><code class="language-ocaml translatable">{shared{
  open Eliom_content.Html5.D
  open Common
}}
{client{
  open Client
}}
open Server</code></pre><p>And then we define the function adding the <span class="teletype">onload</span> handler.
</p><pre class=""><code class="language-ocaml translatable">let start_drawing name image canvas =
  let bus = get_bus name in
  Eliom_service.onload
    {{
      let canceller = launch_client_canvas %bus %image %canvas in
      Eliom_client.on_unload (fun () -&gt; stop_drawing canceller)
    }}</code></pre><p>The function registered by <span><a href=".././../../eliom/latest/api/server/Eliom_service#VALon_unload">Eliom_service.on_unload</a></span> will be called when the page change
inside the application.
</p><p>And we finally register the service sending a drawing:
</p><pre class=""><code class="language-ocaml translatable">let counter = ref 0

let () = My_app.register ~service:multigraffiti_service
  (fun name () -&gt;
    (* Some browsers won't reload the image, so we force
       them by changing the url each time. *)
    incr counter;
    let image =
      img ~alt:name
        ~src:(make_uri
		~service:imageservice (name,!counter)) () in
    let canvas =
      canvas ~a:[ a_width width; a_height height ]
        [pcdata &quot;your browser doesn't support canvas&quot;; br (); image] in
    start_drawing name image canvas;
    make_page
      [h1 [pcdata name];
       choose_drawing_form ();
       canvas;])</code></pre><p>At this point, you can run your application on the server provided that you installed the css and images directories in the main directory of your application, build it using this <span><a href=".././manual/files/tutorial/chapter3/multigraffiti/Makefile">{{{Makefile}}}</a></span> along with this <span><a href=".././manual/files/tutorial/chapter3/multigraffiti/Makefile.common">{{{Makefile.common}}}</a></span> and configured it using <span><a href=".././manual/files/tutorial/chapter3/multigraffiti/graffiti.conf.in">{{{graffiti.conf.in}}}</a></span> as groundwork of configuration file.
</p><h3>Mixing client/server application with traditional Web interaction</h3><p>We now want to restrict the site to connected users.
</p><p>From the previous chapter, we copy the code handling users to <span class="teletype">server.ml</span>:
</p><pre class=""><code class="language-ocaml translatable">let connection_service =
  Eliom_service.post_coservice' ~post_params:
    (let open Eliom_parameter in (string &quot;name&quot; ** string &quot;password&quot;)) ()
let disconnection_service = Eliom_service.post_coservice'
  ~post_params:Eliom_parameter.unit ()
let create_account_service =
  Eliom_service.post_coservice ~fallback:main_service ~post_params:
  (let open Eliom_parameter in (string &quot;name&quot; ** string &quot;password&quot;)) ()

let username = Eliom_reference.eref ~scope:Eliom_common.session None

let users = ref [&quot;user&quot;,&quot;password&quot;;&quot;test&quot;,&quot;test&quot;]

let check_pwd name pwd =
 try Lwt.return (List.assoc name !users = pwd) with
   | Not_found -&gt; Lwt.return false

let () = Eliom_registration.Action.register
  ~service:create_account_service
  (fun () (name, pwd) -&gt;
    users := (name, pwd)::!users;
    Lwt.return ())

let () = Eliom_registration.Action.register
  ~service:connection_service
  (fun () (name, password) -&gt;
    match_lwt check_pwd name password with
      | true -&gt; Eliom_reference.set username (Some name)
      | false -&gt; Lwt.return ())

let () =
  Eliom_registration.Action.register
    ~service:disconnection_service
    (fun () () -&gt; Eliom_state.discard ~scope:Eliom_common.session ())

let disconnect_box () =
  post_form disconnection_service
    (fun _ -&gt; [fieldset
                 [string_input ~input_type:`Submit ~value:&quot;Log out&quot; ()]]) ()

let login_name_form service button_text =
  post_form ~service
    (fun (name1, name2) -&gt;
      [fieldset
         [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
          string_input ~input_type:`Text ~name:name1 ();
          br ();
          label ~a:[a_for name2] [pcdata &quot;password: &quot;];
          string_input ~input_type:`Password ~name:name2 ();
          br ();
          string_input ~input_type:`Submit ~value:button_text ()
         ]]) ()</code></pre><p>We make a customized registration module such that disconnected users
(those for which the username reference is not set), are automaticaly
shown a connection box. That way the other pages can assume that the
username is always available.
</p><pre class=""><code class="language-ocaml translatable">let default_content () =
  make_page
    [h1 [pcdata &quot;Welcome to Multigraffiti&quot;];
     h2 [pcdata &quot;log in&quot;];
     login_name_form connection_service &quot;Connect&quot;;
     h2 [pcdata &quot;create account&quot;];
     login_name_form create_account_service &quot;Create account&quot;;]

module Connected_translate =
struct
  type page = string -&gt; My_app.page Lwt.t
  let translate page =
    Eliom_reference.get username &gt;&gt;=
      function
	| None -&gt; default_content ()
	| Some username -&gt; page username
end

module Connected =
  Eliom_registration.Customize ( My_app ) ( Connected_translate )

let ( !% ) f = fun a b -&gt; return (fun c -&gt; f a b c)</code></pre><p>We replace the previous <span class="teletype">main_service</span> registration :
</p><pre class=""><code class="language-ocaml translatable">let () = My_app.register ~service:main_service
  (fun () () -&gt;
    make_page [h1 [pcdata &quot;Welcome to Multigraffiti&quot;];
	       choose_drawing_form ()])</code></pre><p>by :
</p><pre class=""><code class="language-ocaml translatable">let () = Connected.register ~service:main_service
  !% (fun () () username -&gt;
    make_page
      [h1 [pcdata (&quot;Welcome to Multigraffiti &quot; ^ username)];
       choose_drawing_form ()])</code></pre><p>to use that, in <span class="teletype">graffiti.eliom</span> we just replace
</p><pre class=""><code class="language-ocaml translatable">let () = My_app.register ~service:multigraffiti_service
  (fun name () -&gt; ... )</code></pre><p>by
</p><pre class=""><code class="language-ocaml translatable">let () = Connected.register ~service:multigraffiti_service
  !% (fun name () username -&gt; ...</code></pre><p>and add a call to <span class="teletype">disconnect_box</span>
</p><pre class=""><code class="language-ocaml translatable">[h1 [pcdata name];
       disconnect_box ();
       choose_drawing_form ();
       canvas;])</code></pre><h3>Type safe database requests using Macaque</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Type safe database requests</p></aside><p>In this section we will replace our dumb user handling code (<span class="teletype">check_pwd</span>, <span class="teletype">connection_service</span> and <span class="teletype">create_account_service</span>) by one using a real database backend.
</p><p>We will implement our database access function using
the Macaque library, that allows easy manipulation of Postgresql
database fully compatible with Lwt. (For more information see
<a href="https://github.com/ocsigen/macaque" class="ocsimore_phrasing_link"> Macaque manual</a>).
</p><p>We will store the login and the password of users in a Postgresql
database. For more information on how to set up and run it, see
<a href="http://www.postgresql.org/docs/9.0/static/index.html" class="ocsimore_phrasing_link">Postgresql
manual</a>.
</p><p>When the base is up and running, we create the base by running is a shell:
</p><pre class="manually-translated"><code class="language-sh">$ createdb testbase</code></pre><p>Then we create the <span class="teletype">users</span> table, by executing this sql script:
</p><pre class="manually-translated"><code class="language-sql">CREATE TABLE users (
       login text NOT NULL,
       password text NOT NULL
);</code></pre><p>We save it under <span class="teletype">create_table.sql</span> and run
</p><pre class="manually-translated"><code class="language-sh">$ psql -d testbase -f create_table.sql</code></pre><p>Macaque can use any thread library that provides a monadic
interface. The default one provides simple blocking access to the
database. It isn't good for us because an access to the base by one
user will prevent the server from handling anything else until the
request is finished. We need a version of Macaque specialised for
Lwt. It is obtained by
</p><pre class=""><code class="language-ocaml translatable">module Lwt_thread = struct
  include Lwt
  include Lwt_chan
end
module Lwt_PGOCaml = PGOCaml_generic.Make(Lwt_thread)
module Lwt_Query = Query.Make_with_Db(Lwt_thread)(Lwt_PGOCaml)</code></pre><p>We can now open the database with our newly created <span class="teletype">Lwt_PGOCaml.connect</span>.
</p><pre class=""><code class="language-ocaml translatable">let get_db : unit -&gt; unit Lwt_PGOCaml.t Lwt.t =
  let db_handler = ref None in
  fun () -&gt;
    match !db_handler with
      | Some h -&gt; Lwt.return h
      | None -&gt; Lwt_PGOCaml.connect ~database:&quot;testbase&quot; ()</code></pre><p>Then we declare the table on which we will work and the different
requests we do on it. (We no longer need the <span class="teletype">users</span> array reference)
</p><pre class=""><code class="language-ocaml translatable">let table = &lt;:table&lt; users (
  login text NOT NULL,
  password text NOT NULL
) &gt;&gt;

let find name =
  (get_db () &gt;&gt;= fun dbh -&gt;
   Lwt_Query.view dbh
   &lt;:view&lt; {password = user_.password} |
            user_ in $table$;
            user_.login = $string:name$; &gt;&gt;)

let insert name pwd =
  get_db () &gt;&gt;= fun dbh -&gt;
  Lwt_Query.query dbh
  &lt;:insert&lt; $table$ :=
    { login = $string:name$; password = $string:pwd$; } &gt;&gt;</code></pre><p>Finally, we modify the handling code :
</p><pre class=""><code class="language-ocaml translatable">let check_pwd name pwd =
  (get_db () &gt;&gt;= fun dbh -&gt;
   Lwt_Query.view dbh
   &lt;:view&lt; {password = user_.password} |
            user_ in $table$;
            user_.login = $string:name$;
	    user_.password = $string:pwd$ &gt;&gt;)
  &gt;|= (function [] -&gt; false | _ -&gt; true)

let () = Eliom_registration.Action.register
  ~service:create_account_service
  (fun () (name, pwd) -&gt;
    find name &gt;&gt;=
      (function
	| [] -&gt; insert name pwd
	| _ -&gt; Lwt.return ()) )

let () = Eliom_registration.Action.register
  ~service:connection_service
  (fun () (name, password) -&gt;
    check_pwd name password &gt;&gt;=
      (function
	| true -&gt; Eliom_reference.set username (Some name)
	| false -&gt; Lwt.return ()))</code></pre><p>We need to reference <span class="teletype">macaque</span> in the <span class="teletype">makefile</span> :
</p><pre>SERVER_PACKAGE := cairo, unix, macaque.syntax
</pre><p>and in <span class="teletype">graffiti.conf.in</span> :
</p><pre>&lt;extension findlib-package=&quot;macaque&quot;/&gt;
</pre><h3>Lightweight database using Ocsipersist</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Persistent tables with Ocsipersist</p></aside><p>For maintaining the list of user and password, we do not need the full
power of a SQL database, a key/value table is sufficient. Ocsigen has
such a simple table mechanism directly integrated: Ocsipersist.
</p><p>We first create a table holding ocaml values:
</p><pre class=""><code class="language-ocaml translatable">let user_table = Ocsipersist.open_table &quot;user_table&quot;</code></pre><p>Then we can easily replace the user management code:
</p><pre class=""><code class="language-ocaml translatable">let check_pwd name pwd =
  try_lwt
    lwt saved_password = Ocsipersist.find user_table name in
    Lwt.return (pwd = saved_password)
  with
    Not_found -&gt; Lwt.return false

let () = Eliom_registration.Action.register
  ~service:create_account_service
  (fun () (name, pwd) -&gt; Ocsipersist.add user_table name pwd)

let () = Eliom_registration.Action.register
  ~service:connection_service
  (fun () (name, password) -&gt;
    match_lwt check_pwd name password with
      | true -&gt; Eliom_reference.set username (Some name)
      | false -&gt; Lwt.return ())</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Ocsipersist</h5></header><p>Ocsipersist provides simple typed key/value tables. It provides different backends
(currently sqlite and dbm) and can be extended.
For more informations see <span><a href=".././../../ocsigenserver/latest/api/Ocsipersist#TYPEtable">Ocsipersist.table</a></span>.</p></aside><h3>Saving favorite pictures</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Atom feed</p></aside><p>We will now add a button to the application to save the current
image. The images will be saved to the filesystem using the module
<span><a href=".././../../lwt/latest/api/Lwt_io">Lwt_io</a></span>. We will then make an Atom feed
with the saved images using <span><a href=".././../../eliom/dev/api/Atom_feed">Atom_feed</a></span>.
</p><p>We save the images in the directory containing the static contents
under the directory <span class="teletype">graffiti_saved/username</span>. The <span class="teletype">username</span>
directory is created if needed. If it already exists <span class="teletype">mkdir</span> fails
and we do nothing.
</p><p>We will add this code in a new file:
</p><h4><span class="teletype">feed.ml</span></h4><pre class=""><code class="language-ocaml translatable">open Eliom_content
open Eliom_content.Html5.D
open Server

let static_dir = &quot;/tmp/static/&quot;

let image_dir name =
  let dir = static_dir ^ &quot;/graffiti_saved/&quot; ^ (Url.encode name) in
  (try_lwt Lwt_unix.mkdir dir 511 with
    | _ -&gt; debug &quot;could not create the directory %s&quot; dir; Lwt.return ())
  &gt;|= (fun () -&gt; dir)

let make_filename name number =
  image_dir name &gt;|= fun dir -&gt;
  dir ^ &quot;/&quot; ^ (string_of_int number) ^ &quot;.png&quot;

let save image name number =
  lwt file_name = make_filename name number in
  lwt out_chan = Lwt_io.open_file ~mode:Lwt_io.output file_name in
  Lwt_io.write out_chan image</code></pre><p>We number images and associate to each image the time of creation. It
is stocked in an <span><a href=".././../../eliom/latest/api/Ocsipersist">Ocsipersist</a></span>
table.
</p><pre class=""><code class="language-ocaml translatable">let image_info_table = Ocsipersist.open_table &quot;image_info_table&quot;</code></pre><p>For each user, we stock a value of type<br/>
<span class="teletype"> int * CalendarLib.Calendar.t * ((int * CalendarLib.Calendar.t) list)</span>.
The first integer is the name under which will be saved the image, the first time is the last update for that user and the list contains the names and times of old images. We need those times to timestamp the entries of the feed.
</p><pre class=""><code class="language-ocaml translatable">let save_image username =
  let now = CalendarLib.Calendar.now () in
  lwt number,_,list =
    try_lwt Ocsipersist.find image_info_table username with
      | Not_found -&gt; Lwt.return (0,now,[])
      | e -&gt; Lwt.fail e
  in
  lwt () = Ocsipersist.add image_info_table
    username (number+1,now,(number,now)::list) in
  let (_,image_string) = Hashtbl.find graffiti_info username in
  save (image_string ()) username number

let save_image_box name =
  let save_image_service =
    Eliom_registration.Action.register_post_coservice'
      ~post_params:Eliom_parameter.unit
      (fun () () -&gt; save_image name)
  in
  post_form save_image_service
    (fun _ -&gt;
      [p [string_input ~input_type:`Submit ~value:&quot;save&quot; ()]]) ()</code></pre><p>We find the url of the images with <span><a href=".././../../eliom/latest/api/server/Eliom_service#VALstatic_dir">Eliom_service.static_dir</a></span>.
It is a service taking file path as
parameter, serving the content of the static directory. We use <span><a href=".././../../eliom/latest/api/Eliom_uri#VALmake_string_uri">Eliom_uri.make_string_uri</a></span> to get the
url as a string.
</p><pre class=""><code class="language-ocaml translatable">let feed_service = Eliom_service.service ~path:[&quot;feed&quot;]
  ~get_params:(Eliom_parameter.string &quot;name&quot;) ()

let local_filename name number =
  [&quot;graffiti_saved&quot;; Url.encode name ; (string_of_int number) ^ &quot;.png&quot;]

let rec entries name list = function
  | 0 -&gt; []
  | len -&gt;
    match list with
      | [] -&gt; []
      | (n,saved)::q -&gt;
	let title = Atom_feed.plain
	  (&quot;graffiti &quot; ^ name ^ &quot; &quot; ^ (string_of_int n)) in
	let uri =
	  Eliom_content.Xhtml.F.make_uri ~absolute:true
	    ~service:(Eliom_service.static_dir ())
	    (local_filename name n)
	in
	let entry =
	  Atom_feed.entry ~title ~id:uri ~updated:saved
            [Atom_feed.xhtmlC [ Xhtml.F.img ~src:uri ~alt:&quot;image&quot; ()]] in
	entry::(entries name q (len - 1))

let feed name () =
  let id = Eliom_content.Xhtml.F.make_uri
    ~absolute:true
    ~service:feed_service name in
  let title = Atom_feed.plain (&quot;nice drawings of &quot; ^ name) in
  Lwt.catch
    (fun () -&gt; Ocsipersist.find image_info_table name &gt;|=
	(fun (number,updated,list) -&gt;
	  Atom_feed.feed ~id ~updated ~title (entries name list 10)))
    ( function Not_found -&gt;
      let now = CalendarLib.Calendar.now () in
      Lwt.return (Atom_feed.feed ~id ~updated:now ~title [])
      | e -&gt; Lwt.fail e )

let () = Eliom_atom.Reg.register ~service:feed_service feed</code></pre><p>In <span class="teletype">graffiti.eliom</span>, we add a link to the feed and a save button
that appears only if the user owns the page.
</p><pre class=""><code class="language-ocaml translatable">open Server
open Feed

...


  disconnect_box ();
  choose_drawing_form ();
  a feed_service [pcdata &quot;atom feed&quot;] name;
    div (if name = username
      then [save_image_box name]
      else [pcdata &quot;no saving&quot;]);
    canvas;])</code></pre><p>Before running, make sure <span class="teletype">feed</span> is targeted in the Makefile :
</p><pre>SERVER_FILES = common.ml server.ml feed.ml ${wildcard *.eliom}
</pre><p>and edit
<span class="teletype">let static_dir = &quot;/tmp/static/&quot;</span> to adapt to your configuration.
</p><h3>Custom configuration options</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Custom configuration options</p></aside><p>It is not convenient to have to edit the code to change some
configurations, like the location where are saved the favorite
images. Fortunately Ocsigen provides a mechanism to extend its
configuration file.
</p><pre class=""><code class="language-ocaml translatable">let static_dir =
  match Eliom_config.get_config () with
    | [Simplexmlparser.Element
     (&quot;staticdir&quot;, [], [Simplexmlparser.PCData dir])] -&gt;
        dir
    | [] -&gt;
      raise (Ocsigen_extensions.Error_in_config_file
               (&quot;staticdir must be configured&quot;))
    | _ -&gt;
      raise (Ocsigen_extensions.Error_in_config_file
               (&quot;Unexpected content inside graffiti config&quot;))</code></pre><p>This will add a mandatory child to the eliom tag of graffiti in the
configuration file:
</p><pre>&lt;eliom module=&quot;path/to/graffiti.cma&quot;&gt;
  &lt;staticdir&gt;/tmp/static&lt;/staticdir&gt;
&lt;/eliom&gt;
</pre><h3>Connection with external accounts</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>openID</p></aside><aside class="wip"><header><h5>Work in progress</h5></header><p>Eliom has an openID module. This section has not been written yet.
It will show an example of use of this module.</p></aside><pre class=""><code class="language-ocaml translatable"></code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span></h5></header></aside><h3>Listening music</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Persistence of the client application</p></aside><p>We will add an audio player to the page that will stay when page
changes. This emphasises the fact that browsing inside an application
does not stop the client side code: the music keeps playing when the
content of the page and the url change.
</p><h4><span class="teletype">graffiti.eliom</span></h4><p>We first create the player node at toplevel.
</p><pre class=""><code class="language-ocaml translatable">let player =
  Eliom_content.Html5.Id.create_global_elt
    (audio
       ~srcs:(make_uri (Eliom_service.static_dir ())
                  [&quot;music.ogg&quot;],
              [])
       ~a:[a_autoplay (`Autoplay);a_controls (`Controls)]
       [pcdata &quot;Your browser does not support audio element&quot; ])</code></pre><p>And we insert the player in the page:
</p><pre class=""><code class="language-ocaml translatable">...
       canvas;
       player])</code></pre><p>And that's all ! Since the <span class="teletype">player</span> node is declared unique, no new
player is created when the page changed: this is exact same node.
</p><aside class="wip"><header><h5>Work in progress</h5></header><p>In fact browser stops pause the player as soon as the dom
element is manipulated. That happens when we change the page: to
continue playing the player should not be present as an element of the
page</p></aside><p>To run this example, you will need to add an ogg file in the static directory. If you can't find one, there is one here:
<a href="http://www.gnu.org/music/free-software-song.html" class="ocsimore_phrasing_link">http://www.gnu.org/music/free-software-song.html</a>.</p></article></div></div></body></html>
